<h1>About Milvus</h1>
<h2>What is Milvus</h2>
<h4>Overview</h4>
<p>Milvus is an open-source vector database that is highly flexible, reliable, and blazing fast. It supports adding,
  deleting, updating, and near real-time search of vectors on a trillion-byte scale. A comprehensive set of intuitive
  APIs, and support for multiple widely adopted index libraries (e.g., Faiss, NMSLIB, and Annoy), simplifies the process
  of choosing the right index type for a given scenario. Additionally, support for scalar data filtering ensures Milvus
  maintains a high recall rate and remains adaptable.</p>
<p>Milvus runs on a client-server model. At a high-level, it operates as follows:</p>
<ul>
  <li>
    <p>The Milvus server includes the Milvus Core and Meta Store.</p>
    <ul>
      <li>
        <p>Milvus Core stores and manages vectors and scalar data.</p>
      </li>
      <li>
        <p>Meta Store stores and manages metadata in SQLite for testing or MySQL for production.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>On the client side, Milvus provides SDKs in Python, Java, Go, and C++, as well as RESTful APIs.</p>
  </li>
</ul>
<p>Milvus was released under the open-source Apache License 2.0 in October 2019, and its source code was made available
  on <a href="https://github.com/milvus-io/milvus">GitHub</a>. In June 2021, Milvus graduated from the <a
    href="https://lfaidata.foundation/">LF AI &amp; Data Foundation’s</a> incubator program.</p>
<div class="alert note">
  The Milvus server runs on a standalone node. For scenarios involving large datasets or requiring high concurrency
  consider Mishards, our cluster sharding middleware.
</div>
<h4>Overall architecture</h4>
<p><img src="../../../assets/milvus_arch.png" alt="Milvus architecture"></p>
<h4>Scenarios</h4>
<p>Milvus has been used in hundreds of organizations and institutions worldwide including the following scenarios:</p>
<ul>
  <li>Image, video, and audio search.</li>
  <li>Recommender systems, chatbots, and other text search fields.</li>
  <li>New drug discovery, genetic screening, and other biomedical fields.</li>
</ul>
<p>See <a href="https://www.milvus.io/scenarios/">Scenarios</a> for more information.</p>
<h4>Key features</h4>
<h5>Heterogeneous computing</h5>
<ul>
  <li>Optimizes search and indexing performance on GPU.</li>
  <li>Searches trillion-byte scale datasets in milliseconds.</li>
  <li>Manages inserting, deleting, updating, and querying vector data in a dynamic environment.</li>
</ul>
<h5>Compatible with mainstream libraries, metrics, and tooling</h5>
<ul>
  <li>Offers support for Faiss, NMSLIB, and Annoy libraries.</li>
  <li>Supports graph- and tree-based indexes as well as quantization.</li>
  <li>Measures similarity using Euclidean distance (L2), inner product, Hamming distance, Jaccard distance, and more.
  </li>
  <li>Monitors and visualizes runtime metrics using Prometheus and Grafana.</li>
</ul>
<h5>Near-real-time (NRT) search</h5>
<ul>
  <li>Newly inserted datasets are available for search in one second or less.</li>
</ul>
<h5>Scalar field filtering (coming soon)</h5>
<ul>
  <li>Makes search more flexible by allowing data to be filtered more granularly.</li>
</ul>
<h4>Milvus distributions</h4>
<p><a name='distributions'></a></p>
<p>Milvus is available in CPU-only and GPU-enabled distributions:</p>
<ul>
  <li>The CPU-only Milvus distribution relies on CPU exclusively to search and build indexes.
  </li>
  <li>The GPU-enabled Milvus distribution supports GPU acceleration for search and index building. For example, CPU can
    be used for search while GPU is used for index building, improving query efficiency.</li>
</ul>
<p>For GPUs that support CUDA, the GPU-enabled Milvus distribution can be used to achieve much better search performance
  when working with large-scale datasets.</p>
<p>See <a href="milvus_distributions-cpu.md">Milvus Distributions</a> for more information…</p>
<h4>Join our community</h4>
<p>Before joining our developer community, please take some time to read <a
    href="https://github.com/milvus-io/milvus/blob/master/CONTRIBUTING.md#contributing-to-milvus">our code contribution
    guidelines</a>.</p>
<p>For questions about Milvus’ functionality or SDKs, join our <a
    href="https://github.com/milvus-io/milvus/discussions">GitHub Discussions</a> or <a
    href="https://join.slack.com/t/milvusio/shared_invite/zt-e0u4qu3k-bI2GDNys3ZqX1YCJ9OM~GQ">Slack channel</a>.</p>
<h2>Milvus Distributions</h2>
<h4>Overview</h4>
<p>Milvus is available in CPU-only and GPU-enabled distributions:</p>
<ul>
  <li>The CPU-only Milvus distribution relies on CPU exclusively to search and build indexes.
  </li>
  <li>The GPU-enabled Milvus distribution supports GPU acceleration for search and index building. For example, CPU can
    be used for search while GPU is used for index building, improving query efficiency.</li>
</ul>
<p>For GPUs that support CUDA, the GPU-enabled Milvus distribution can be used to achieve much better search performance
  when working with large-scale datasets.</p>
<div class="tab-wrapper"><a href="milvus_distributions-cpu.md" class='active '>CPU-only Milvus</a><a
    href="milvus_distributions-gpu.md" class=''>GPU-enabled Milvus</a></div>
<h4>Indexes for CPU-only Milvus</h4>
<p>Milvus maps different embedding types with different index types. Click the tab below to view the index types
  supporting your embedding type.</p>
<div class="filter">
  <a href="#floating">Floating point embeddings</a> <a href="#binary">Binary embeddings</a>
</div>
<div class="filter-floating table-wrapper" markdown="block">
  <table>
    <thead>
      <tr>
        <th>Index type</th>
        <th>Indexing with CPU</th>
        <th>Indexing with GPU</th>
        <th>Search with CPU</th>
        <th>Search with GPU</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>FLAT</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>✔️</td>
        <td>❌</td>
      </tr>
      <tr>
        <td>IVF_FLAT</td>
        <td>✔️</td>
        <td>❌</td>
        <td>✔️</td>
        <td>❌</td>
      </tr>
      <tr>
        <td>IVF_SQ8</td>
        <td>✔️</td>
        <td>❌</td>
        <td>✔️</td>
        <td>❌</td>
      </tr>
      <tr>
        <td>IVF_PQ</td>
        <td>✔️</td>
        <td>❌</td>
        <td>✔️</td>
        <td>❌</td>
      </tr>
      <tr>
        <td>RNSG</td>
        <td>✔️</td>
        <td>❌</td>
        <td>✔️</td>
        <td>❌</td>
      </tr>
      <tr>
        <td>HNSW</td>
        <td>✔️</td>
        <td>❌</td>
        <td>✔️</td>
        <td>❌</td>
      </tr>
      <tr>
        <td>Annoy</td>
        <td>✔️</td>
        <td>❌</td>
        <td>✔️</td>
        <td>❌</td>
      </tr>
    </tbody>
  </table>
</div>
<div class="filter-binary table-wrapper" markdown="block">
  <table>
    <thead>
      <tr>
        <th>Index type</th>
        <th>Indexing with CPU</th>
        <th>Indexing with GPU</th>
        <th>Search with CPU</th>
        <th>Search with GPU</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>FLAT</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>✔️</td>
        <td>❌</td>
      </tr>
      <tr>
        <td>IVF_FLAT</td>
        <td>✔️</td>
        <td>❌</td>
        <td>✔️</td>
        <td>❌</td>
      </tr>
    </tbody>
  </table>
</div>
<h2>Announcement Letter</h2>
<h4>Milvus 1.0: The World’s Most Popular Open-Source Vector Database Just Got Better</h4>
<p>Zilliz is proud to announce the release of Milvus v1.0. After months of extensive testing Milvus v1.0, which is based
  on a stable version of Milvus v0.10.6, is available for use.</p>
<p>Milvus v1.0 offers the following key features:</p>
<ul>
  <li>Support for mainstream similarity metrics, including Euclidean distance, inner product, Hamming distance, Jaccard
    coefficient, and more.</li>
  <li>Integration with, and improvements to, SOTA ANNs algorithms, including Faiss, Hnswlib, Annoy, NSG, and more.</li>
  <li>Scale-out capability through the Mishards sharding proxy.</li>
  <li>Support for processors commonly used in AI scenarios, including X86, Nvidia GPU, Xilinx FPGA, and more.</li>
</ul>
<p>See the <a href="release_notes.md">Release Notes</a> for additional Milvus v1.0 features.</p>
<p>Milvus is an ongoing open-source software (OSS) project. Its first major release has the following implications for
  users:</p>
<ul>
  <li>Milvus v1.0 will receive long-term support (3+ years).</li>
  <li>The most stable Milvus release to-date is well structured and ready for integration with existing AI ecosystems.
  </li>
</ul>
<h4>The first version of Milvus with long-term support</h4>
<p>Thanks in part to sponsorship from Zilliz, the Milvus community will provide bug fix support for Milvus v1.0 until
  December 31st, 2024. New features will be available only in releases following v1.0.</p>
<p>See <a href="milvus_release_guideline.md">The Milvus release guideline</a> for information about release cadences and
  more.</p>
<h4>Toolchain enhancements and seamless AI ecosystem integration</h4>
<p>Beginning with v1.0, Milvus’ toolchain will be a primary development focus. We plan to create the necessary tooling
  and utilities to meet the needs of the Milvus user community.</p>
<p>Stability makes integrating Milvus with AI ecosystems a breeze. We are seeking further collaboration between the
  Milvus community and other AI-focused OSS communities. We encourage contributions to the new AI ASICs
  (application-specific integrated circuits) in Milvus.</p>
<h4>The future of Milvus</h4>
<p>We believe Milvus has a bright future thanks to the following factors:</p>
<ul>
  <li>Regular contributions from developers in the Milvus community.</li>
  <li>Support for integration with any cloud-native environment.</li>
</ul>
<p>We have drafted <a href="milvus_community_charters.md">community charters</a> to help guide, nurture, and advance the
  Milvus community as our technology and user base grows. The charters include several technical decisions made to
  attract more participants to the community.</p>
<ul>
  <li>Golang will now be used to develop the Milvus engine however, the ANNS algorithm component will still be developed
    in C++.</li>
  <li>The forthcoming distributed version of Milvus will use existing cloud components as much as possible.</li>
</ul>
<p>We are thrilled to partner with the open-source software community to build the next-generation cloud data fabric
  made for AI. Let’s get to work!</p>
<h4>Don’t be a stranger</h4>
<ul>
  <li>Find or contribute to Milvus on <a href="https://github.com/milvus-io/milvus/">GitHub</a></li>
  <li>Interact with the community via <a
      href="https://join.slack.com/t/milvusio/shared_invite/zt-e0u4qu3k-bI2GDNys3ZqX1YCJ9OM~GQ">Slack</a>.</li>
  <li>Connect with us on <a href="https://twitter.com/milvusio">Twitter</a>.</li>
</ul>
<h2>Milvus Data Migration Guide</h2>
<p>This migration guide deals with migrating data from Milvus v0.7.0~0.10.6 to Milvus v1.0.0.</p>
<div class="alert note">
  <ul>
    <li>Milvus v0.11.0 and versions earlier than v0.7.0 are incompatible with v1.0.0.</li>
    <li><a href="milvusdm.md">MilvusDM</a> supports migrating data from Milvus v0.10.x to v1.0.0</li>
  </ul>
</div>
<h4>Step 1: Stop Current Version of Milvus</h4>
<p>Stop the current version of Milvus:</p>
<pre><code>docker stop [Your_milvus_container_id]
</code></pre>
<p>Delete <strong>/conf</strong>, <strong>/logs</strong>, and <strong>/wal</strong> under <strong>/milvus</strong>:</p>
<pre><code>cd ~/milvus
sudo rm -rf ./conf
sudo rm -rf ./logs
sudo rm -rf ./wal
</code></pre>
<div class="alert note">Save a copy of the logs folder if you want to retain log files.</div>
<h4>Step 2: Download the v1.0.0 Configuration File</h4>
<p>Create a <strong>conf</strong> directory and download the v1.0.0 configuration file:</p>
<pre><code>mkdir conf
cd conf
wget https://raw.githubusercontent.com/milvus-io/milvus/v1.1.0/core/conf/demo/server_config.yaml
</code></pre>
<div class="alert note">If the download is unsuccessful, you can open the download URL on a web page, create a new file
  with the same name in the conf directory, then save the web page content by copying it to the new file.</div>
<h4>Step 3: Update the Server Address of MySQL/SQLite</h4>
<pre><code>vim ./server_config.yaml
</code></pre>
<p>Ensure that the MySQL/SQLite server address specified in <code>general.meta_uri</code> matches the server address
  specified in <code>db_config.backend_url</code>. If you use MySQL to manage metadata, the configuration information
  appears as follows:</p>
<pre><code>general:
timezone:UTC+8
meta_uri: mysql://root:123456@&lt;MySQL_server_host IP&gt;:3306/milvus
</code></pre>
<h4>Step 4: Download and Start Milvus v1.0.0</h4>
<p>Download and run a Milvus v1.0.0 docker image using the same mapping path setting:</p>
<pre><code>$ sudo docker run -d --name milvus_cpu_1.1.0 \
-p 19530:19530 \
-p 19121:19121 \
-v /home/$USER/milvus/db:/var/lib/milvus/db \
-v /home/$USER/milvus/conf:/var/lib/milvus/conf \
-v /home/$USER/milvus/logs:/var/lib/milvus/logs \
-v /home/$USER/milvus/wal:/var/lib/milvus/wal \
milvusdb/milvus:1.1.0-cpu-d050721-5e559c
</code></pre>
<h4>Step 5: Install the Python SDK Corresponding to Milvus v1.0.0</h4>
<pre><code>pip3 install pymilvus==1.1.0
</code></pre>
<h4>Step 6: Verify Data Correctness</h4>
<p>Write and run a Python script to verify if the data is correct.</p>
<h1>Concepts</h1>
<h2>Embedding Vector</h2>
<h4>Definition</h4>
<p>An embedding vector is a series of numbers and can be considered as a matrix with only one row but multiple columns,
  such as [2,0,1,9,0,6,3,0].</p>
<p>An embedding vector includes information representing the characteristics of an object, such as RGB (red-green-blue)
  color descriptions. A color can be described by the proportions of red, green, and blue. An embedding vector in RGB
  could be [R, G, B].</p>
<h4>Advantages</h4>
<p>Advances in modern computer and machine learning technologies have led to massive amounts of multimedia data in
  diverse application fields such as real estate, pharmaceutical, and financial information services. A multimedia
  object cannot be simply described by alphanumeric data because a multimedia object have multiple dimensions of
  properties.</p>
<p>Instead, embedding vectors describe an object in a multi-dimensional, easily analyzable way, and are suitable to
  represent numeric or symbolic characteristics of multimedia content.</p>
<p>Embedding vectors are important for many different fields of machine learning and pattern recognition. Machine
  learning algorithms typically require a numerical representation of objects in order for the algorithms to perform
  statistical analysis.</p>
<h4>Scenarios</h4>
<p>Embedding vectors, with its effectiveness and practicality of numerically representing objects, are used widely in
  different fields of machine learning.</p>
<ul>
  <li>
    <p>Image processing</p>
    <p>Features can be gradient magnitudes, colors, grayscale intensities, edges, areas, and more. Embedding vectors are
      particularly popular in image processing because it is easy to define numeric attributes for images.</p>
  </li>
  <li>
    <p>Speech recognition</p>
    <p>Features can be sound lengths, noise levels, noise ratios, and more.</p>
  </li>
  <li>
    <p>Spam filtering</p>
    <p>Features can be IP addresses, text structures, frequencies of certain words, certain email headers, and more.</p>
  </li>
</ul>
<h2>Vector Index</h2>
<h4>Vector index</h4>
<p>Vector index is a time-efficient and space-efficient data structure built on vectors through a certain mathematical
  model. Through the vector index, we can efficiently query several vectors similar to the target vector.</p>
<p>Since accurate retrieval is usually very time-consuming, most of the vector index types of Milvus use ANNS
  (Approximate Nearest Neighbors Search). Compared with accurate retrieval, the core idea of ANNS is no longer limited
  to returning the most accurate result, but only searching for neighbors of the target. ANNS improves retrieval
  efficiency by sacrificing accuracy within an acceptable range.</p>
<p>According to the implementation methods, the ANNS vector index can be divided into four categories:</p>
<ul>
  <li>Tree-based index</li>
  <li>Graph-based index</li>
  <li>Hash-based index</li>
  <li>Quantization-based index</li>
</ul>
<p>The following table classifies the indexes that Milvus supports:</p>
<table>
  <thead>
    <tr>
      <th>Supported index</th>
      <th>Classification</th>
      <th>Scenario</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#FLAT">FLAT</a></td>
      <td>N/A</td>
      <td>
        <ul>
          <li>Has a relatively small dataset.</li>
          <li>Requires a 100% recall rate. </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><a href="#IVF_FLAT">IVF_FLAT</a></td>
      <td>Quantization-based index</td>
      <td>
        <ul>
          <li>High-speed query.</li>
          <li>Requires a recall rate as high as possible.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><a href="#IVF_SQ8">IVF_SQ8</a></td>
      <td>Quantization-based index</td>
      <td>
        <ul>
          <li>High-speed query.</li>
          <li>Limited disk and memory capacity. </li>
          <li>Has CPU resources only.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><a href="#IVF_SQ8H">IVF_SQ8H</a></td>
      <td>Quantization-based index</td>
      <td>
        <ul>
          <li>High-speed query. </li>
          <li>Limited disk, memory, and graphics memory capacities. </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><a href="#IVF_PQ">IVF_PQ</a></td>
      <td>Quantization-based index</td>
      <td></td>
    </tr>
    <tr>
      <td><a href="#RNSG">RNSG</a></td>
      <td>Graph-based index</td>
      <td></td>
    </tr>
    <tr>
      <td><a href="#HNSW">HNSW</a></td>
      <td>Graph-based index</td>
      <td></td>
    </tr>
    <tr>
      <td><a href="#Annoy">Annoy</a></td>
      <td>Tree-based index</td>
      <td></td>
    </tr>
  </tbody>
</table>
<h4>Vector field and index</h4>
<p>To improve query performance, you can specify an index type for each vector field. Currently, a vector field only
  supports one index type, Milvus will automatically delete the old index when switching the index type.</p>
<h4>Create indexes</h4>
<p>When the <code>create_index()</code> method is called, Milvus synchronously indexes the existing data on this field.
  Whenever the size of the inserted data reaches the <code>index_file_size</code>, Milvus automatically creates an index
  for it in the background.</p>
<div class="alert note">
  When the inserted data segment is less than 4096 rows, Milvus does not index it.
</div>
<h4>Index by segment</h4>
<p>Milvus stores massive data in sections. When indexing, Milvus creates an index for each data segment separately.</p>
<h4>Build indexes during free time</h4>
<p>It is known that indexing is a resource-consuming and time-consuming task. When the query task and indexing task are
  concurrent, Milvus preferentially allocates computing resources to the query task, that is, any query command will
  interrupt the indexing task being executed in the background. After that, only when the user does not send the query
  task for 5 seconds, Milvus resumes the indexing task in the background. Besides, if the data segment specified by the
  query command has not been built into the specified index, Milvus will do an exhaustive search directly within the
  segment.</p>
<h4>Supported vector indexes</h4>
<h4>FLAT</h4>
<p><a name="FLAT"></a></p>
<p>If FLAT index is used, the vectors are stored in an array of float/binary data without any compression. during
  searching vectors, all indexed vectors are decoded sequentially and compared to the query vectors.</p>
<p>FLAT index provides 100% query recall rate. Compared to other indexes, it is the most efficient indexing method when
  the number of queries is small.</p>
<ul>
  <li>
    <p>Search parameters</p>
    <table>
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Range</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>metric_type</code></td>
          <td>[Optional] The chosen distance metric.</td>
          <td>See <a href="metric.md#floating">Supported Metrics</a>.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>
<h4>IVF_FLAT</h4>
<p><a name="IVF_FLAT"></a></p>
<p>IVF (Inverted File) is an index type based on quantization. It divides the points in space into <code>nlist</code>
  units by clustering method. during searching vectors, it compares the distances between the target vector and the
  center of all the units, and then select the <code>nprobe</code> nearest unit. Then, it compares all the vectors in
  these selected cells to get the final result.</p>
<p>IVF_FLAT is the most basic IVF index, and the encoded data stored in each unit is consistent with the original data.
</p>
<ul>
  <li>
    <p>Index building parameters</p>
    <table>
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Range</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>nlist</code></td>
          <td>Number of cluster units</td>
          <td>[1, 65536]</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>Search parameters</p>
    <table>
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Range</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>nprobe</code></td>
          <td>Number of units to query</td>
          <td>CPU: [1, nlist] <br> GPU: [1, min(2048, nlist)]</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>
<h4>IVF_SQ8</h4>
<p><a name="IVF_SQ8"></a></p>
<p>IVF_SQ8 does scalar quantization for each vector placed in the unit based on IVF. Scalar quantization converts each
  dimension of the original vector from a 4-byte floating-point number to a 1-byte unsigned integer, so the IVF_SQ8
  index file occupies much less space than the IVF_FLAT index file. However, scalar quantization results in a loss of
  accuracy during searching vectors.</p>
<ul>
  <li>IVF_SQ8 has the same index building parameters as IVF_FLAT.</li>
  <li>IVF_SQ8 has the same search parameters as IVF_FLAT.</li>
</ul>
<h4>IVF_SQ8H</h4>
<p><a name="IVF_SQ8H"></a></p>
<p>Optimized version of IVF_SQ8 that requires both CPU and GPU to work. Unlike IVF_SQ8, IVF_SQ8H uses a GPU-based coarse
  quantizer, which greatly reduces time to quantize.</p>
<p>IVF_SQ8H is an IVF_SQ8 index that optimizes query execution.</p>
<p>The query method is as follows:</p>
<ul>
  <li>
    <p>If <code>nq</code> ≥ <code>gpu_search_threshold</code>, GPU handles the entire query task.</p>
  </li>
  <li>
    <p>If <code>nq</code> &lt; <code>gpu_search_threshold</code>, GPU handles the task of retrieving the
      <code>nprobe</code> nearest unit in the IVF index file, and CPU handles the rest.
    </p>
  </li>
  <li>
    <p>IVF_SQ8H has the same index building parameters as IVF_FLAT.</p>
  </li>
  <li>
    <p>IVF_SQ8H has the same search parameters as IVF_FLAT.</p>
  </li>
</ul>
<h4>IVF_PQ</h4>
<p><a name="IVF_PQ"></a></p>
<p><code>PQ</code> (Product Quantization) uniformly decomposes the original high-dimensional vector space into Cartesian
  products of <code>m</code> low-dimensional vector spaces, and then quantizes the decomposed low-dimensional vector
  spaces. In the end, each vector is stored in <code>m</code> × <code>nbits</code> bits. Instead of calculating the
  distances between the target vector and the center of all the units, product quantization enables the calculation of
  distances between the target vector and the clustering center of each low-dimensional space and greatly reduces the
  time complexity and space complexity of the algorithm.</p>
<p>IVF_PQ quantizes the products of vectors before IVF index clustering. Its index file is even smaller than IVF_SQ8,
  but it also causes a loss of accuracy during searching vectors.</p>
<div class="alert note">
  Index building parameters and search parameters vary with Milvus distribution. Select your Milvus distribution first.
</div>
<div class="filter">
  <a href="#CPU">CPU-only Milvus</a> <a href="#GPU">GPU-enabled Milvus </a>
</div>
<div class="filter-CPU" markdown="block">
  <ul>
    <li>
      <p>Index building parameters</p>
      <table>
        <thead>
          <tr>
            <th>Parameter</th>
            <th>Description</th>
            <th>Range</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>nlist</code></td>
            <td>Number of cluster units</td>
            <td>[1, 65536]</td>
          </tr>
          <tr>
            <td><code>m</code></td>
            <td>Number of factors of product quantization</td>
            <td>dim ≡ 0 (mod m)</td>
          </tr>
          <tr>
            <td><code>nbits</code></td>
            <td>[Optional] Number of bits in which each low-dimensional vector is stored.</td>
            <td>[1, 16] (8 by default)</td>
          </tr>
        </tbody>
      </table>
    </li>
    <li>
      <p>Search parameters</p>
      <table>
        <thead>
          <tr>
            <th>Parameter</th>
            <th>Description</th>
            <th>Range</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>nprobe</code></td>
            <td>Number of units to query</td>
            <td>[1, nlist]</td>
          </tr>
        </tbody>
      </table>
    </li>
  </ul>
</div>
<div class="filter-GPU" markdown="block">
  <ul>
    <li>
      <p>Index building parameters</p>
      <table>
        <thead>
          <tr>
            <th>Parameter</th>
            <th>Description</th>
            <th>Range</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>nlist</code></td>
            <td>Number of cluster units</td>
            <td>[1, 65536]</td>
          </tr>
          <tr>
            <td><code>m</code></td>
            <td>Number of factors of product quantization</td>
            <td><code>m</code> ∈ {1, 2, 3, 4, 8, 12, 16, 20, 24, 28, 32, 40, 48, 56, 64, 96}, and (dim / m) ∈ {1, 2, 3,
              4, 6, 8, 10, 12, 16, 20, 24, 28, 32}.<br>(<code>m</code> x 1024) ≤ <code>MaxSharedMemPerBlock</code> of
              your graphics card.</td>
          </tr>
          <tr>
            <td><code>nbits</code></td>
            <td>[Optional] Number of bits in which each low-dimensional vector is stored.</td>
            <td>8</td>
          </tr>
        </tbody>
      </table>
    </li>
  </ul>
  <div class="alert note">
    <ul>
      <li>If the value of <code>m</code> does not fall into the specified range for GPU indexing but into the range of
        CPU indexing, Milvus switches to using CPU to build the index (click the button above to view the range
        supported by CPU-enabled Milvus).</li>
      <li>If the specified value of <code>nbits</code> is between 1 and 16 but not 8, the system switches back to
        CPU-only Milvus.</li>
    </ul>
  </div>
  <ul>
    <li>
      <p>Search parameters</p>
      <table>
        <thead>
          <tr>
            <th>Parameter</th>
            <th>Description</th>
            <th>Range</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>nprobe</code></td>
            <td>Number of units to query</td>
            <td>[1, min(2048, nlist)]</td>
          </tr>
        </tbody>
      </table>
    </li>
  </ul>
  <div class="alert note">
    If the value of <code>nprobe</code> does not fall into the specified range but into the range for CPU search, Milvus
    switches to CPU search (click the button above to view the range supported by CPU-enabled Milvus).
  </div>
</div>
<h4>RNSG</h4>
<p><a name="RNSG"></a></p>
<p>RNSG (Refined Navigating Spreading-out Graph) is a graph-based indexing algorithm. It sets the center position of the
  whole image as a navigation point, and then uses a specific edge selection strategy to control the out-degree of each
  point (less than or equal to <code>out_degree</code>). Therefore, it can reduce memory usage and quickly locate the
  target position nearby during searching vectors.</p>
<p>The graph construction process of RNSG is as follows:</p>
<ol>
  <li>Find <code>knng</code> nearest neighbors for each point.</li>
  <li>Iterate at least <code>search_length</code> times based on <code>knng</code> nearest neighbor nodes to select
    <code>candidate_pool_size</code> possible nearest neighbor nodes.
  </li>
  <li>Construct the out-edge of each point in the selected <code>candidate_pool_size</code> nodes according to the edge
    selection strategy.</li>
</ol>
<p>The query process is similar to the graph building process. It starts from the navigation point and iterate at least
  <code>search_length</code> times to get the final result.
</p>
<ul>
  <li>
    <p>Index building parameters</p>
    <table>
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Range</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>out_degree</code></td>
          <td>Maximum out-degree of the node</td>
          <td>[5, 300]</td>
        </tr>
        <tr>
          <td><code>candidate_pool_size</code></td>
          <td>Candidate pool size of the node</td>
          <td>[50, 1000]</td>
        </tr>
        <tr>
          <td><code>search_length</code></td>
          <td>Number of query iterations</td>
          <td>[10, 300]</td>
        </tr>
        <tr>
          <td><code>knng</code></td>
          <td>Number of nearest neighbors</td>
          <td>[5, 300]</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>Search parameters</p>
    <table>
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Range</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>search_length</code></td>
          <td>Number of query iterations</td>
          <td>[10, 300]</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>
<h4>HNSW</h4>
<p><a name="HNSW"></a></p>
<p>HNSW (Hierarchical Small World Graph) is a graph-based indexing algorithm. It builds a multi-layer navigation
  structure for an image according to certain rules. In this structure, the upper layers are more sparse and the
  distances between nodes are farther; the lower layers are denser and the distances between nodes are closer. The
  search starts from the uppermost layer, finds the node closest to the target in this layer, and then enters the next
  layer to begin another search. After multiple iterations, it can quickly approach the target position.</p>
<p>In order to improve performance, HNSW limits the maximum degree of nodes on each layer of the graph to
  <code>M</code>. In addition, you can use <code>efConstruction</code> (when building index) or <code>ef</code> (when
  searching targets) to specify a search range.
</p>
<ul>
  <li>
    <p>Index building parameters</p>
    <table>
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Range</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>M</code></td>
          <td>Maximum degree of the node</td>
          <td>[4, 64]</td>
        </tr>
        <tr>
          <td><code>efConstruction</code></td>
          <td>Search scope</td>
          <td>[8, 512]</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>Search parameters</p>
    <table>
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Range</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>ef</code></td>
          <td>Search scope</td>
          <td>[<code>top_k</code>, 32768]</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>
<h4>Annoy</h4>
<p><a name="Annoy"></a></p>
<p>Annoy (Approximate Nearest Neighbors Oh Yeah) is an index that uses a hyperplane to divide a high-dimensional space
  into multiple subspaces, and then stores them in a tree structure.</p>
<p>When searching for vectors, Annoy follows the tree structure to find subspaces closer to the target vector, and then
  compares all the vectors in these subspaces (The number of vectors being compared should not be less than
  <code>search_k</code>) to obtain the final result. Obviously, when the target vector is close to the edge of a certain
  subspace, sometimes it is necessary to greatly increase the number of searched subspaces to obtain a high recall rate.
  Therefore, Annoy uses <code>n_trees</code> different methods to divide the whole space, and searches all the dividing
  methods simultaneously to reduce the probability that the target vector is always at the edge of the subspace.
</p>
<ul>
  <li>
    <p>Index building parameters</p>
    <table>
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Range</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>n_trees</code></td>
          <td>The number of methods of space division.</td>
          <td>[1, 1024]</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>Search parameters</p>
    <table>
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Range</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>search_k</code></td>
          <td>The number of nodes to search. -1 means 5% of the whole data.</td>
          <td>{-1} ∪ [<code>top_k</code>, n × <code>n_trees</code>]</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>
<h4>How to choose an index</h4>
<p>To learn how to choose an appropriate index for your application scenarios, please read <a
    href="https://medium.com/@milvusio/how-to-choose-an-index-in-milvus-4f3d15259212">How to Select an Index in
    Milvus</a>.</p>
<p>To learn how to choose an appropriate index for a metric, see <a href="metric.md">Distance Metrics</a>.</p>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">Does IVF_SQ8 differ from IVF_SQ8H in terms of recall rate?
    </font>
  </summary>
  No, they have the same recall rate for the same dataset.
</details>
<details>
  <summary>
    <font color="#4fc4f9">What is the difference between FLAT index and IVF_FLAT index?</font>
  </summary>
  <p>IVF_FLAT index divides a vector space into <code>nlist</code> clusters. If you keep the default value of
    <code>nlist</code> as 16384, Milvus compares the distances between the target vector and the centers of all 16384
    clusters to get <code>nprobe</code> nearest clusters. Then Milvus compares the distances between the target vector
    and the vectors in the selected clusters to get the nearest vectors. Unlike IVF_FLAT, FLAT directly compares the
    distances between the target vector and each and every vector.
  </p>
  <p>
    Therefore, when the total number of vectors approximately equals <code>nlist</code>, IVF_FLAT and FLAT has little
    difference in the way of calculation required and search performance. But as the number of vectors grows to two
    times, three times, or n times of <code>nlist</code>, IVF_FLAT index begins to show increasingly greater advantages.
  </p>
  <p>
    See <a href="https://medium.com/unstructured-data-service/how-to-choose-an-index-in-milvus-4f3d15259212">How to
      Choose an Index in Milvus</a> for more information.
  </p>
</details>
<h4>Bibliography</h4>
<ul>
  <li>RNSG: <a href="http://www.vldb.org/pvldb/vol12/p461-fu.pdf">Fast Approximate Nearest Neighbor Search With The
      Navigating Spreading-out Graph</a></li>
  <li>HNSW: <a href="https://arxiv.org/abs/1603.09320">Efficient and robust approximate nearest neighbor search using
      Hierarchical Navigable Small World graphs</a></li>
  <li>Annoy: <a
      href="https://erikbern.com/2015/10/01/nearest-neighbors-and-vector-models-part-2-how-to-search-in-high-dimensional-spaces.html">Nearest
      neighbors and vector models – part 2 – algorithms and data structures</a></li>
</ul>
<h2>Storage Concepts</h2>
<h4>Partition and segment</h4>
<p>When creating a collection, Milvus controls the size of a data segment according to the <code>index_file_size</code>.
  Also, Milvus provides partition function, you can divide the data into multiple partitions as needed. Reasonable
  organization and division of data can effectively improve query performance.</p>
<h5>Segment</h5>
<p>To process massive data, Milvus segments the data and each segment of data has tens or even hundreds of thousands of
  entities. Milvus separates the data in each segment by fields and stores the data in each field a data file. In the
  current version, an entity contains only one ID field and one vector field, so each segmented data file mainly
  includes a UID file and an original vector data file.</p>
<p>The size of a segment is determined by the <code>index_file_size</code> (1,024 MB by default and 4,096 MB at most)
  when Milvus is creating the collection.</p>
<p>When building indexes, Milvus builds an index for each segment in the collection in order and stores the index into a
  separate file. Index files are independent of each other. Indexing can significantly improve retrieval performance.
</p>
<h5>Partition</h5>
<p>After a collection has accumulated massive data, the query performance gradually declines. In some scenarios, only
  part of the data in a collection needs to be queried, so Milvus divides the data in the collection into multiple parts
  on physical storage based on certain rules. Such operation is called partitioning. Each partition can contain multiple
  segments.</p>
<p>A partition is identified by a tag. When inserting vector data, you can use the tag to specify which partition to
  insert the data into. When querying vector data, you can use the tag to specify the partition where the query should
  be executed. Milvus supports both the exact matching and regular expression matching for partition tags.</p>
<div class="alert note">
  Each collection can have 4096 partitions at most.
</div>
<h5>The relationship between collections, partitions and segments</h5>
<p>The relationship between collections, partitions, and segments is as follows:</p>
<p><img src="../../../assets/storage/hierarchy.png" alt="file"></p>
<div class="alert info">
  Each collection has a <code>_default</code> section. If no partition is specified when inserting data, Milvus inserts
  the data into the <code>_default</code> partition.
</div>
<h4>Metadata</h4>
<p>Both the partition or segment are organizational forms of data in physical storage. When querying data, Milvus must
  know the location and status information of each data file on the physical storage, including the collection it
  belongs to, the number of entities it contains, the file size, the globally unique identifier, and the creation date,
  which are called metadata. In addition, the metadata also contains collection and partition information, including
  collection name, collection dimension, index type, partition label, and so on.</p>
<p>When data changes, the metadata should change accordingly and be easy to obtain. Therefore, it is an ideal choice to
  use a transactional database to manage metadata. Milvus provides SQLite or MySQL as a backend service for metadata and
  MySQL is recommended for production environments or distributed services.</p>
<p>The metadata back-end service is not responsible for storing entity data and indexes.</p>
<p><img src="../../../assets/storage/meta.png" alt="meta"></p>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">Can I use SQL Server or PostgreSQL to store metadata in Milvus?</font>
  </summary>
  No, we only support storing metadata using SQLite or MySQL.
</details>
<h2>Storage Operations</h2>
<div class="alert note">
  Please read <a href="storage_concept.md">Storage Concepts</a> before reading this article.
</div>
<h4>Insert data</h4>
<p>The client inserts data by calling the <code>insert</code> API, and the amount of inserted data cannot exceed 256 MB
  at a time. The process of data insertion is as follows:</p>
<ol>
  <li>After receiving the insert request, the server writes the data to the write ahead log (WAL).</li>
  <li>After the request is successfully recorded to the log file, the server handles the insert operation.</li>
  <li>The server writes data to a mutable buffer.</li>
</ol>
<div class="alert note">
  Each collection has an independent mutable buffer. The maximum capacity of each mutable buffer is 128 MB. The upper
  limit of the total mutable buffer capacity of all collections is determined by <code>insert_buffer_size</code> (by
  default 1 GB).
</div>
<p><img src="../../../assets/storage/insert.png" alt="insert"></p>
<h4>Flush data</h4>
<p>There are three triggering mechanisms for data flushing in the buffer:</p>
<h5>Timed trigger</h5>
<p>The system triggers the data flushing task regularly. The interval is determined by the
  <code>auto_flush_interval</code> (by default 1 second).
</p>
<p>The process of data flushing is as follows:</p>
<ol>
  <li>The system opens up a new mutable buffer area to accommodate the data to be inserted.</li>
  <li>The system sets the previous mutable buffer as read-only (immutable buffer).</li>
  <li>The system writes the data in the immutable buffer to the disk and writes the description information of the new
    data segment to the metadata backend service.</li>
</ol>
<p>After completing the above process, the system has successfully created a segment.</p>
<h5>Client trigger</h5>
<p>The client calls the <code>flush</code> API to trigger the data flushing task.</p>
<h5>Trigger when the buffer reaches the upper limit</h5>
<p>When the accumulated data reaches the upper limit of the mutable buffer (128MB), the data flushing task is triggered.
</p>
<p>All relevant files of each segment are stored in a folder named by the segment ID, such as a UID file that records
  the entity ID, a <strong>delete_docs</strong> file used to mark deleted entities, and a <strong>bloom-filter</strong>
  file used for quick entity search.</p>
<div class="alert info">
  Please see the diagram in <a href="storage_concept.md#Partition-and-segment">Partition and Segment</a> for data files
  within the segment.
</div>
<h4>Merge data</h4>
<p>Too many small data segments cause poor query performance. To address this problem, Milvus triggers the segment merge
  task in the background when needed. In other words, Milvus merges small data segments into new data segments, deletes
  the small data segments, and updates the metadata. The size of new data segments should not be less than the
  <code>index_file_size</code>.
</p>
<p>The timings to trigger the merge task are as follows:</p>
<ul>
  <li>When starting the service</li>
  <li>After completing a data flushing task</li>
  <li>Before building indexes</li>
  <li>After deleting the indexes</li>
</ul>
<div class="alert note">
  The indexed segments do not participate in the merge task.
</div>
<h4>Build indexes</h4>
<p>Before building indexes, Milvus performs query operations on collections by brute-force search. To improve query
  performance, you can build a suitable index for the collection. After the index is built, Milvus generates an index
  file for each segment and simultaneously updates the metadata.</p>
<div class="alert info">
  See <a href="index.md">Index Types</a> for more information about building indexes.
</div>
<h4>Delete</h4>
<h5>Delete collections</h5>
<ol>
  <li>The client calls the <code>drop_collection</code> API to delete a collection.</li>
  <li>After receiving the request, the server marks the collection (including its partitions and segments) as deleted in
    the metadata. No new operations (such as insertion and query) can be performed on these collections.</li>
  <li>The background cleanup task deletes the collection (including its partitions and segments) marked as deleted from
    the metadata and deletes the corresponding data files and folders from the disk. If there is an operation being
    performed on the collection before the delete operation is called, the segment is deleted after the previous
    operation is completed.</li>
</ol>
<h5>Delete partitions</h5>
<ol>
  <li>The client calls the <code>drop_partition</code> API to delete a partition.</li>
  <li>After receiving the request, the server marks the partition (including its segment) as deleted in the metadata.
  </li>
  <li>The background cleanup task performs the same process as described in <strong>Delete collections</strong> to
    delete the partition and metadata.</li>
</ol>
<h5>Delete entities</h5>
<p>Milvus created a <strong>delete_docs</strong> file for each segment to record the position of the vectors to be
  deleted within the segment.</p>
<p>Milvus uses a bloom filter to quickly determine whether an entity ID exists in a segment. Therefore, a file named
  <strong>bloom_filter</strong> is created under each segment.
</p>
<p>The process of deleting an entity is as follows:</p>
<ol>
  <li>The client calls the <code>delete_entity_by_id</code> API to delete some entities in the collection.</li>
  <li>After receiving the request, the server performs the following operations to delete the entities:
    <ul>
      <li>If an entity is the insertion buffer, the server deletes the entity directly.</li>
      <li>Otherwise, based on the bloom filter of each segment, the server determines which segment contains the entity,
        and then updates the <strong>delete_docs</strong> and <strong>bloom_filter</strong> files of the segment.</li>
    </ul>
  </li>
</ol>
<h4>Compact segments</h4>
<p>When querying a segment, Milvus reads the entity data of the segment and the <strong>delete_docs</strong> file into
  memory. Although the deleted entities do not participate in the calculation, they are read into memory. Therefore, the
  more deleted entities in a segment, the more memory resources and disk space are wasted. To reduce such unnecessary
  resource consumption, Milvus provides data segment compaction operation, the process is as follows:</p>
<ol>
  <li>The client calls the <code>compact</code> API.</li>
  <li>After receiving the request, the server writes the undeleted entities in the segment to a new segment based on the
    information recorded in <strong>delete_docs</strong> and marks the old segment as deleted. Afterward, the background
    cleanup task is responsible for cleaning the segments marked as deleted. If the old segments have been indexed, the
    indexes are rebuilt after the new segments are generated.</li>
</ol>
<div class="alert note">
  The <code>compact</code> operation ignores the segment where the deleted vector accounts for less than 10% of the
  entire data.
</div>
<h4>Read data</h4>
<ol>
  <li>The client calls the <code>get_entity_by_id</code> API to read the original entity data.</li>
  <li>After receiving the request, the server finds the segment where the entity is located through the bloom filter and
    returns the data corresponding to the entity ID.</li>
</ol>
<div class="alert note">
  Floating-point vectors are stored in Milvus as single-precision (float) data.
</div>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">Can I increase my storage by adding interfaces such as S3 or GlusterFS?</font>
  </summary>
  No, you cannot. Milvus does not support this feature for now.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Can I export data from Milvus?</font>
  </summary>
  [Milvus DM](/milvusdm.md#Milvus-to-HDF5) supports exporting data from Milvus to HDF5 file.
  <div class="alert note">
    MilvusDM is supported on Milvus 1.x only.
  </div>
</details>
<h2>Similarity Metrics</h2>
<p>In Milvus, distance metrics are used to measure similarities among vectors. Choosing a good distance metric helps
  improve the classification and clustering performance significantly.</p>
<p>The following table shows how these widely used distance metrics fit with various input data forms and Milvus
  indexes.</p>
<div class="filter">
  <a href="#floating">Floating point embeddings</a> <a href="#binary">Binary embeddings</a>
</div>
<div class="filter-floating table-wrapper" markdown="block">
  <table class="tg">
    <thead>
      <tr>
        <th class="tg-0pky" style="width: 204px;">Distance Metrics</th>
        <th class="tg-0pky">Index Types</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="tg-0pky">Euclidean distance (L2)</td>
        <td class="tg-0pky" rowspan="2">
          <ul>
            <li>FLAT</li>
            <li>IVF_FLAT</li>
            <li>IVF_SQ8</li>
            <li>IVF_SQ8H</li>
            <li>IVF_PQ</li>
            <li>RNSG</li>
            <li>HNSW</li>
            <li>Annoy</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td class="tg-0pky">Inner product (IP)</td>
      </tr>
    </tbody>
  </table>
</div>
<div class="filter-binary table-wrapper" markdown="block">
  <table class="tg">
    <thead>
      <tr>
        <th class="tg-0pky" style="width: 204px;">Distance Metrics</th>
        <th class="tg-0pky">Index Types</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="tg-0pky">
          <ul>
            <li>Jaccard</li>
            <li>Tanimoto</li>
            <li>Hamming</li>
          </ul>
        </td>
        <td class="tg-0pky">
          <ul>
            <li>FLAT</li>
            <li>IVF_FLAT</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td class="tg-0pky">
          <ul>
            <li>Superstructure</li>
            <li>Substructure</li>
          </ul>
        </td>
        <td class="tg-0pky">FLAT</td>
      </tr>
    </tbody>
  </table>
</div>
<h4>Euclidean distance (L2)</h4>
<p>Essentially, Euclidean distance measures the length of a segment that connects 2 points.</p>
<p>The formula for Euclidean distance is as follows:</p>
<p><img src="../../../assets/euclidean_metric.png" alt="euclidean"></p>
<p>where <strong>a</strong> = (a1, a2,…, an) and <strong>b</strong> = (b1, b2,…, bn) are two points in n-dimensional
  Euclidean space</p>
<p>It’s the most commonly used distance metric, and is very useful when the data is continuous.</p>
<h4>Inner product (IP)</h4>
<p>The IP distance between two embeddings are defined as follows:</p>
<p><img src="../../../assets/IP_formula.png" alt="ip"></p>
<p>where A and B are embeddings, <code>||A||</code> and <code>||B||</code> are the norms of A and B.</p>
<p>IP is more useful if you are more interested in measuring the orientation but not the magnitude of the vectors.</p>
<div class="alert note">
  If you use IP to calculate embeddings similarities, you must normalize your embeddings. After normalization, inner
  product equals cosine similarity.
</div>
<p>Suppose X’ is normalized from embedding X:</p>
<p><img src="../../../assets/normalize_formula.png" alt="normalize"></p>
<p>The correlation between the two embeddings is as follows:</p>
<p><img src="../../../assets/normalization_formula.png" alt="normalization"></p>
<h4>Jaccard distance</h4>
<p>Jaccard similarity coefficient measures the similarity between two sample sets, and is defined as the cardinality of
  the intersection of the defined sets divided by the cardinality of the union of them. It can only be applied to finite
  sample sets.</p>
<p><img src="../../../assets/jaccard_coeff.png" alt="Jaccard similarity coefficient"></p>
<p>Jaccard distance measures the dissimilarity between data sets, and is obtained by subtracting the Jaccard similarity
  coefficient from 1. For binary variables, Jaccard distance is equivalent to Tanimoto coefficient.</p>
<p><img src="../../../assets/jaccard_dist.png" alt="Jaccard distance"></p>
<h4>Tanimoto distance</h4>
<p>For binary variables, the Tanimoto coefficient is equivalent to Jaccard distance:</p>
<p><img src="../../../assets/tanimoto_coeff.png" alt="tanimoto coefficient"></p>
<p>In Milvus, the Tanimoto coefficient is only applicable for a binary variable, and for binary variables the Tanimoto
  coefficient ranges from 0 to +1 (where +1 is the highest similarity).</p>
<p>For binary variables, the formula of Tanimoto distance is:</p>
<p><img src="../../../assets/tanimoto_dist.png" alt="tanimoto distance"></p>
<p>The value ranges from 0 to +infinity.</p>
<h4>Hamming distance</h4>
<p>Hamming distance measures binary data strings. The distance between two strings of equal length is the number of bit
  positions at which the bits are different.</p>
<p>For example, suppose there are two strings 1101 1001 and 1001 1101.</p>
<p>11011001 ⊕ 10011101 = 01000100. Since, this contains two 1s, the Hamming distance, d (11011001, 10011101) = 2.</p>
<h4>Superstructure</h4>
<p>Superstructure is used to measure the similarity of a chemical structure and its superstructure. The less the value,
  the more similar the structure is to its superstructure. Only the vectors whose distance equals to 0 can be found now.
</p>
<p>Superstructure similarity can be measured by:</p>
<p><img src="../../../assets/superstructure.png" alt="superstructure"></p>
<p>Where</p>
<ul>
  <li>B is the superstructure of A</li>
  <li>N<sub>A</sub> specifies the number of bits in the fingerprint of molecular A.</li>
  <li>N<sub>B</sub> specifies the number of bits in the fingerprint of molecular B.</li>
  <li>N<sub>AB</sub> specifies the number of shared bits in the fingerprint of molecular A and B.</li>
</ul>
<h4>Substructure</h4>
<p>Substructure is used to measure the similarity of a chemical structure and its substructure. The less the value, the
  more similar the structure is to its substructure. Only the vectors whose distance equals to 0 can be found now.</p>
<p>Substructure similarity can be measured by:</p>
<p><img src="../../../assets/substructure.png" alt="substructure"></p>
<p>Where</p>
<ul>
  <li>B is the substructure of A</li>
  <li>N<sub>A</sub> specifies the number of bits in the fingerprint of molecular A.</li>
  <li>N<sub>B</sub> specifies the number of bits in the fingerprint of molecular B.</li>
  <li>N<sub>AB</sub> specifies the number of shared bits in the fingerprint of molecular A and B.</li>
</ul>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">Why is the top1 result of a vector search not the search vector itself, if the metric type is
      inner product?</font>
  </summary>
  This occurs if you have not normalized the vectors when using inner product as the distance metric.
</details>
<details>
  <summary>
    <font color="#4fc4f9">What is normalization? Why is normalization needed?</font>
  </summary>
  <p>Normalization refers to the process of converting an embedding (vector) so that its norm equals 1. If you use Inner
    Product to calculate embeddings similarities, you must normalize your embeddings. After normalization, inner product
    equals cosine similarity.
  </p>
  <p>
    See <a href="https://en.wikipedia.org/wiki/Unit_vector">Wikipedia</a> for more information.
  </p>
</details>
<details>
  <summary>
    <font color="#4fc4f9">Why do I get different results using Euclidean distance (L2) and inner product (IP) as the
      distance metric?</font>
  </summary>
  Check if the vectors are normalized. If not, you need to normalize the vectors first. Theoretically speaking,
  similarities worked out by L2 are different from similarities worked out by IP, if the vectors are not normalized.
</details>
<h2>Write Ahead Log</h2>
<p><img src="../../../assets/wal/wal_workflow.png" alt="wal_structure"></p>
<p>Write ahead log records insertion and deletion requests into the log file, and then the background thread writes it
  to the system. Once the requests are successfully written to the log file, the server returns success. This function
  enhances data reliability and reduces client blocking.</p>
<h4>Data reliability</h4>
<p>Write ahead log guarantees the atomicity of modification requests. All requests that receives success messages are
  completely written to the system. For requests that do not receive and respondence due to an unexpected system exit or
  an unexpected link disconnection, the operation is either succeed or fail. Whether the operation is successful can be
  confirmed by calling other interfaces. In addition, when the system restarts, some requests in the log file are
  re-executed if they have not been applied to the system state.</p>
<h4>Buffer settings</h4>
<p>The buffer size of the write ahead log is determined by the <code>wal.buffer_size</code>. To ensure the write
  performance of the write ahead log, we recommend setting the buffer size to at least twice the size of the data
  imported in a single batch.</p>
<div class="alert note">
  For more information about how to set <code>wal.buffer_size</code>, see <a href="milvus_config.md">Milvus
    configuration</a>.
</div>
<h4>Delete old log files</h4>
<p>Milvus automatically deletes log files that have been applied to the system.</p>
<h2>Milvus Terms</h2>
<h4>Milvus Terminology</h4>
<ul>
  <li>
    <p><strong>Collection</strong>: A collection that consists of a set of entities and are equivalent to a table in an
      RDBMS.</p>
  </li>
  <li>
    <p><strong>Segment</strong>: A data file that Milvus automatically creates by merging inserted data. A collection
      can contain multiple segments. One segment can contain multiple entities. During search, Milvus searches each
      segment, filters deleted data, and returns the combined result.</p>
  </li>
  <li>
    <p><strong>Entity</strong>: A group of fields that correspond to real world objects. These fields can be structured
      data representing object properties or vectors representing object features.</p>
  </li>
  <li>
    <p><strong>Entity ID</strong>: A guaranteed unique value that can be used to always reference an entity.</p>
    <div class="alert note">
      Currently, Milvus does not support entity ID de-duplication and it is possible to have duplicate IDs in a segment.
    </div>
  </li>
  <li>
    <p><strong>Field</strong>: A field within an entity. A field can either be structured data, such as numbers,
      strings, or unstructured data, such as vectors.</p>
  </li>
  <li>
    <p><strong>Vector</strong>: A type of field representing the feature of an object.</p>
    <div class="alert note">
      Currently, an entity can only contain up to one vector.
    </div>
  </li>
  <li>
    <p><strong>Index</strong>: An index built based on raw data and improves the speed of data retrieval operations on a
      collection.</p>
  </li>
  <li>
    <p><strong>Mapping</strong>: A set of rules that define how data is organized in a collection.</p>
  </li>
</ul>
<h1>Quick Start</h1>
<h2>Installation Overview</h2>
<p>Ensure that you have read <a href="milvus_distributions-cpu.md">Milvus Distributions</a> and understood the
  differences in terms of performance and scenarios.</p>
<p>Docker is the recommended way to install and run Milvus.</p>
<ul>
  <li><a href="milvus_docker-cpu.md">Install CPU-only Milvus on Docker</a></li>
  <li><a href="milvus_docker-gpu.md">Install GPU-enabled Milvus on Docker</a></li>
</ul>
<div class="alert note">
  If you have not set up a Docker environment, see <a
    href="https://github.com/milvus-io/milvus/blob/1.1/INSTALL.md">Build Milvus from Source</a> to learn how to build
  Milvus from source.
</div>
<h2>Install and Start Milvus</h2>
<div class="tab-wrapper"><a href="milvus_docker-cpu.md" class='active '>CPU-only Milvus</a><a
    href="milvus_docker-gpu.md" class=''>GPU-enabled Milvus</a></div>
<h4>Prerequisites</h4>
<h5>Operating System Requirements</h5>
<table>
  <thead>
    <tr>
      <th style="text-align:left">Operating system</th>
      <th style="text-align:left">Supported versions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">CentOS</td>
      <td style="text-align:left">7.5 or higher</td>
    </tr>
    <tr>
      <td style="text-align:left">Ubuntu LTS</td>
      <td style="text-align:left">18.04 or higher</td>
    </tr>
  </tbody>
</table>
<h5>Hardware Requirements</h5>
<table>
  <thead>
    <tr>
      <th>Component</th>
      <th>Recommended configuration</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CPU</td>
      <td>Intel CPU Sandy Bridge or higher.</td>
    </tr>
    <tr>
      <td>CPU Instruction Set</td>
      <td>
        <ul>
          <li>SSE42</li>
          <li>AVX</li>
          <li>AVX2</li>
          <li>AVX512</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>RAM</td>
      <td>8 GB or more (depends on the data volume)</td>
    </tr>
    <tr>
      <td>Hard Drive</td>
      <td>SATA 3.0 SSD or higher</td>
    </tr>
  </tbody>
</table>
<h5>Software Requirements</h5>
<table>
  <thead>
    <tr>
      <th>Software</th>
      <th>Version</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Docker</td>
      <td>19.03 or higher</td>
    </tr>
  </tbody>
</table>
<div class="alert note">
  Please ensure that the available memory is greater than the sum of <code>cache.insert_buffer_size</code> and
  <code>cache.cache_size</code> set in the <b>server_config.yaml</b> file.
</div>
<h4>Confirm Docker Status</h4>
<p>Confirm that the Docker daemon is running in the background:</p>
<pre><code class="language-shell">$ sudo docker info
</code></pre>
<div class="alert note">
  <ul>
    <li>If you do not see the server listed, start the Docker daemon.</li>
    <li>On Linux, Docker needs <code>sudo</code> privileges. To run Docker commands without <code>sudo</code>
      privileges, create a <code>docker</code> group and add your users (see <a
        href="https://docs.docker.com/install/linux/linux-postinstall/">Post-installation Steps for Linux</a> for
      details).</li>
  </ul>
</div>
<h4>Pull Docker Image</h4>
<p>Pull the CPU-only image:</p>
<pre><code class="language-shell">$ sudo docker pull milvusdb/milvus:1.1.0-cpu-d050721-5e559c
</code></pre>
<div class="alert note">
  <ul>
    <li>If you cannot use your host to acquire Docker images and configuration files online because of network
      restrictions, please acquire them online from another available host, save them as a TAR file, pass it on to your
      local machine, and then load the TAR file as a Docker image:
      <details>
        <summary>
          <font color="#3ab7f8">Click here to view the sample code.</font>
        </summary>
        <ol>
          <li>Save the Docker image as a TAR file, and pass it on to your local machine:</br>
            <code class="language-shell">
    $ docker save milvusdb/milvus > milvus_image.tar
</code>
          </li>
          <li>Load the TAR file as a Docker image:</br>
            <code class="language-shell">
    $ docker load < milvus_image.tar
</code>
          </li>
        </ol>
      </details>
    </li>
    <li>If pulling the docker image is too slow or keeps failing, see <a href="operational_faq.md">Operational FAQ</a>
      for solutions.</li>
  </ul>
</div>
<h4>Download Configuration Files</h4>
<pre><code class="language-shell">$ mkdir -p /home/$USER/milvus/conf
$ cd /home/$USER/milvus/conf
$ wget https://raw.githubusercontent.com/milvus-io/milvus/v1.1.0/core/conf/demo/server_config.yaml
</code></pre>
<div class="alert note">
  If you cannot download configuration files via the <code>wget</code> command, you can create a
  <b>server_config.yaml</b> file under <b>/home/$USER/milvus/conf</b>, and then copy the content from <a
    href="https://github.com/milvus-io/milvus/blob/v1.1.0/core/conf/demo/server_config.yaml">server config</a> to it.
</div>
<h4>Start Docker Container</h4>
<p>Start Docker container and map the paths to the local files to the container:</p>
<pre><code class="language-shell">$ sudo docker run -d --name milvus_cpu_1.1.0 \
-p 19530:19530 \
-p 19121:19121 \
-v /home/$USER/milvus/db:/var/lib/milvus/db \
-v /home/$USER/milvus/conf:/var/lib/milvus/conf \
-v /home/$USER/milvus/logs:/var/lib/milvus/logs \
-v /home/$USER/milvus/wal:/var/lib/milvus/wal \
milvusdb/milvus:1.1.0-cpu-d050721-5e559c
</code></pre>
<p>The <code>docker run</code> options used in the above command are defined as follows:</p>
<ul>
  <li><code>-d</code>: Runs container in the background and prints container ID.</li>
  <li><code>--name</code>: Assigns a name to the container.</li>
  <li><code>-p</code>: Publishes a container’s port(s) to the host.</li>
  <li><code>-v</code>: Mounts the directory into the container.</li>
</ul>
<p>Confirm the running state of Milvus:</p>
<pre><code class="language-shell">$ sudo docker ps
</code></pre>
<p>If the Milvus server does not start up properly, check the error logs:</p>
<pre><code class="language-shell">$ sudo docker logs milvus_cpu_1.1.0
</code></pre>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">Can I install Milvus on Windows?</font>
  </summary>
  Yes, so long as you have set up a Docker environment on your operating system.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Why does Milvus return <code>Illegal instruction</code> during startup?</font>
  </summary>
  If your CPU does not support SSE42, AVX, AVX2, or AVX512, Milvus cannot start properly. You can use
  <code>cat /proc/cpuinfo</code> to check the supported instruction sets.
</details>
<details>
  <summary>
    <font color="#4fc4f9">How to migrate data in Milvus?</font>
  </summary>
  For details, see <a href="data_migration.md">data migration</a>.
  <div class="alert note">
    Data formats of different versions may not be compatible with each other. The current data format is backward
    compatible with Milvus v0.7.0.
  </div>
</details>
<details>
  <summary>
    <font color="#4fc4f9">Is Docker the only way to install and run Milvus?</font>
  </summary>
  No. You can also build Milvus from source code in Linux. See <a
    href="https://github.com/milvus-io/milvus/blob/master/INSTALL.md">Build Milvus from source code</a> for more
  information.
</details>
<details>
  <summary>
    <font color="#4fc4f9">How to set <code>nlist</code> or <code>nprobe</code> for IVF indexes?</font>
  </summary>
  In general terms, the recommended value of <code>nlist</code> is <code>4 &times; sqrt(n)</code>, where n is the total
  number of entities in a segment.
  <p>Determining <code>nprobe</code> is a trade-off between search performance and accuracy, and based on your dataset
    and scenario. It is recommended to run several rounds of tests to determine the value of <code>nprobe</code>.</p>
  <p>The following charts are from a test running on the sift50m dataset and IVF_SQ8 index. The test compares search
    performance and recall rate between different <code>nlist</code>/<code>nprobe</code> pairs.</p>
  <div class="alert note">
    <p>We only show the results of GPU-enabled Milvus here, because the two distributions of Milvus show similar
      results.</p>
  </div>
  <img src="../../../../assets/accuracy_nlist_nprobe.png" alt="accuracy_nlist_nprobe.png">
  <p>Key takeaways: This test shows that the recall rate increases with the <code>nlist</code>/<code>nprobe</code> pair.
  </p>
  <img src="../../../../assets/performance_nlist_nprobe.png" alt="performance_nlist_nprobe.png">
  <p>Key takeaways: When <code>nlist</code> is 4096 and <code>nprobe</code> 128, Milvus shows the best search
    performance.</p>
</details>
<h4>What’s next</h4>
<ul>
  <li>
    <p>If you’re just getting started with Milvus:</p>
    <ul>
      <li><a href="example_code.md">Try an example program</a></li>
      <li><a href="connect_milvus_python.md">Learn basic Milvus operations</a></li>
      <li><a href="https://github.com/zilliz-bootcamp">Try Milvus Bootcamp</a></li>
    </ul>
  </li>
  <li>
    <p>If you’re ready to run Milvus in production:</p>
    <ul>
      <li>Build a <a href="monitor.md">monitoring and alerting system</a> to check real-time application performance.
      </li>
      <li>Tune Milvus performance through <a href="milvus_config.md">configuration</a>.</li>
    </ul>
  </li>
  <li>
    <p>If you want to use GPU-accelerated Milvus for search in large datasets:</p>
    <ul>
      <li><a href="milvus_docker-gpu.md">Install GPU-enabled Milvus</a></li>
    </ul>
  </li>
</ul>
<h2>Hello Milvus</h2>
<p>After the Milvus server is successfully started, you can use this example program to create a table, insert 10
  vectors, and then run a vector similarity search.</p>
<ol>
  <li>
    <p>Make sure <a href="https://www.python.org/downloads/">Python 3.6</a> and a compatible <a
        href="https://pip.pypa.io/en/stable/installing/">pip</a> are installed.</p>
  </li>
  <li>
    <p>Install Milvus Python SDK.</p>
    <pre><code class="language-shell">#### Install Milvus Python SDK
$ pip3 install pymilvus==1.1.0
</code></pre>
    <div class="alert note">
      To learn more about Milvus Python SDK, go to <a
        href="https://github.com/milvus-io/pymilvus/blob/v1.0.1/README.md">Milvus Python SDK Readme.</a>
    </div>
  </li>
  <li>
    <p>Download Python example code.</p>
    <pre><code class="language-shell">#### Download Python example
$ wget https://raw.githubusercontent.com/milvus-io/pymilvus/v1.1.0/examples/example.py
</code></pre>
    <div class="alert note">
      If you cannot use <code>wget</code> to download the example code, you can also create <b>example.py</b> and copy
      the <a href="https://github.com/milvus-io/pymilvus/blob/v1.1.0/examples/example.py">example code.</a>
    </div>
  </li>
  <li>
    <p>Run the example code.</p>
    <pre><code class="language-shell">#### Run Milvus Python example
$ python3 example.py
</code></pre>
  </li>
  <li>
    <p>Confirm the program is running correctly.</p>
    <pre><code class="language-shell">Query result is correct.
</code></pre>
  </li>
</ol>
<p>Congratulations! You have successfully completed your first vector similarity search with Milvus.</p>
<h4>What’s next</h4>
<ul>
  <li><a href="connect_milvus_python.md">Learn basic Milvus operations</a> in Milvus</li>
  <li><a href="https://github.com/zilliz-bootcamp">Try Milvus bootcamp</a> to check more solutions</li>
</ul>
<h2>Connect to the Server</h2>
<p>This article describes how to connect to a Milvus server from a Python client.</p>
<div class="alert note">
  <li>See <a href="https://github.com/milvus-io/pymilvus">Python API documentation</a> for details about APIs.</li>
  <li>We recommend using <a href="https://zilliz.com/sizing-tool">Milvus Sizing Tool</a> to estimate the hardware
    resources required for the data.</li>
</div>
<ol>
  <li>
    <p>Import pymilvus:</p>
    <pre><code class="language-python">#### Import pymilvus.
&gt;&gt;&gt; from milvus import Milvus, IndexType, MetricType, Status
</code></pre>
  </li>
  <li>
    <p>Use any of the following methods to connect to the Milvus server:</p>
    <pre><code class="language-python">#### Connect to the Milvus server.
&gt;&gt;&gt; milvus = Milvus(host='localhost', port='19530')
</code></pre>
    <div class="alert note">
      In the above code, <code>host</code> and <code>port</code> both use default values. You can change them to your IP
      address and port.
    </div>
    <pre><code class="language-python">&gt;&gt;&gt; milvus = Milvus(uri='tcp://localhost:19530')
</code></pre>
  </li>
</ol>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">Does Milvus' Python SDK have a connection pool?</font>
  </summary>
  Python SDKs corresponding to Milvus v0.9.0 or later have a connection pool. There is no upper limit on the default
  number of connections in a connection pool.
</details>
<details>
  <summary>
    <font color="#4fc4f9">How to fix the error when I install pymilvus on Windows?</font>
  </summary>
  Try installing pymilvus in a Conda environment.
</details>
<h2>Create/Drop a Collection</h2>
<h4>Create and Drop a Collection</h4>
<p>This article provides Python sample codes for creating or dropping collections.</p>
<div class="alert note">
  See <a href="https://github.com/milvus-io/pymilvus/tree/master/examples">Example Program</a> for more detailed usage.
</div>
<h4>Create a Collection</h4>
<ol>
  <li>
    <p>Prepare the parameters needed to create the collection:</p>
    <pre><code class="language-python">#### Prepare collection parameters.
&gt;&gt;&gt; param = {'collection_name':'test01', 'dimension':256, 'index_file_size':1024, 'metric_type':MetricType.L2}
</code></pre>
  </li>
  <li>
    <p>Create a collection named <code>test01</code>, with a dimension of 256 and an index file size of 1024 MB. It uses
      Euclidean distance (L2) as the distance measurement method.</p>
    <pre><code class="language-python">#### Create a collection.
&gt;&gt;&gt; milvus.create_collection(param)
</code></pre>
  </li>
</ol>
<h4>Drop a Collection</h4>
<pre><code class="language-python">#### Drop a collection.
&gt;&gt;&gt; milvus.drop_collection(collection_name='test01')
</code></pre>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">How can I get the best performance from Milvus through setting <code>index_file_size</code>?
    </font>
  </summary>
  <p>You need to set <code>index_file_size</code> when creating a collection from a client. This parameter specifies the
    size of each segment, and its default value is 1024 in MB. When the size of newly inserted vectors reaches the
    specified volume, Milvus packs these vectors into a new segment. In other words, newly inserted vectors do not go
    into a segment until they grow to the specified volume. When it comes to creating indexes, Milvus creates one index
    file for each segment. When conducting a vector search, Milvus searches all index files one by one.
  </p>
  <p>
    As a rule of thumb, we would see a 30% ~ 50% increase in the search performance after changing the value of
    <code>index_file_size</code> from 1024 to 2048. Note that an overly large <code>index_file_size</code> value may
    cause failure to load a segment into the memory or graphics memory. Suppose the graphics memory is 2 GB and
    <code>index_file_size</code> 3 GB, each segment is obviously too large.
  </p>
  <p>
    In situations where vectors are not frequently inserted, we recommend setting the value of
    <code>index_file_size</code> to 1024 MB or 2048 MB. Otherwise, we recommend setting the value to 256 MB or 512 MB to
    keep unindexed files from getting too large.
  </p>
  See <a href="tuning.md#Index">Performance Tuning > Index</a> for more information.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Can I update <code>index_file_size</code> and <code>metric_type</code> after creating a
      collection?</font>
  </summary>
  No, you cannot.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Is there a limit on the total number of collections and partitions?</font>
  </summary>
  There is no limit on the number of collections. The upper limit on the number of partitions in a collection is 4096.
</details>
<details>
  <summary>
    <font color="#4fc4f9">What is the maximum dimension of a vector in Milvus?</font>
  </summary>
  Milvus can support vectors with up to 32,768 dimensions.
</details>
## Create/Drop a Partition ##
<h4>Create and Drop a Partition</h4>
<p>This article provides Python sample codes for creating or dropping partitions.</p>
<h4>Create a Partition</h4>
<p>To improve search efficiency, you can divide a collection into several partitions by tags. In fact, each partition is
  a collection.</p>
<pre><code class="language-python">#### Create a partition.
&gt;&gt;&gt; milvus.create_partition('test01', 'tag01')
</code></pre>
<h4>Drop a Partition</h4>
<pre><code class="language-python">&gt;&gt;&gt; milvus.drop_partition(collection_name='test01', partition_tag='tag01')
</code></pre>
<h2>Insert/Delete Vectors</h2>
<h4>Insert and Delete Vectors</h4>
<p>You can perform vector operations on collections or partitions. This article talks about the following topics:</p>
<ul>
  <li><a href="#insert-vectors-to-a-collection">Insert vectors to a collection</a></li>
  <li><a href="#insert-vectors-to-a-partition">Insert vectors to a partition</a></li>
  <li><a href="#delete-vectors-by-id">Delete vectors by ID</a></li>
</ul>
<h4>Insert Vectors to a Collection</h4>
<p><a name="insert-vector-to-collection"></a></p>
<ol>
  <li>
    <p>Randomly generate 20 256-dimensional vectors:</p>
    <pre><code class="language-python">&gt;&gt;&gt; import random
#### Generate 20 vectors of 256 dimensions.
&gt;&gt;&gt; vectors = [[random.random() for _ in range(256)] for _ in range(20)]
</code></pre>
  </li>
  <li>
    <p>Insert a list of vectors. If you do not specify vector IDs, Milvus automatically assigns IDs to the vectors.</p>
    <pre><code class="language-python">#### Insert vectors.
&gt;&gt;&gt; milvus.insert(collection_name='test01', records=vectors)
</code></pre>
    <p>You can also specify the vector IDs:</p>
    <pre><code class="language-python">&gt;&gt;&gt; vector_ids = [id for id in range(20)]
&gt;&gt;&gt; milvus.insert(collection_name='test01', records=vectors, ids=vector_ids)
</code></pre>
  </li>
</ol>
<h4>Insert Vectors to a Partition</h4>
<p><a name="insert-vector-to-partition"></a></p>
<pre><code class="language-python">&gt;&gt;&gt; milvus.insert('test01', vectors, partition_tag=&quot;tag01&quot;)
</code></pre>
<h4>Delete Vectors by ID</h4>
<p><a name="delete-vector"></a></p>
<p>Suppose your collection contains the following vector IDs:</p>
<pre><code class="language-python">&gt;&gt;&gt; ids = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
</code></pre>
<p>You can delete the vectors with the following command:</p>
<pre><code class="language-python">&gt;&gt;&gt; milvus.delete_entity_by_id(collection_name='test01', id_array=ids)
</code></pre>
<div class="alert note">
  After calling <code>delete</code>, you can call <code>flush</code> again to ensure that the newly inserted data is
  visible and the deleted data is no longer recoverable.
</div>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">Is there a length limit on the self-defined entity IDs?</font>
  </summary>
  Entity IDs must be non-negative 64-bit integers.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Can I insert vectors with existing IDs?</font>
  </summary>
  Yes, you can. If you insert vectors with an existing ID, you would end up having duplicate IDs.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Does Milvus support inserting while searching?</font>
  </summary>
  Yes.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Is there a volume limit on the vectors inserted each time?</font>
  </summary>
  Vectors inserted each time must not exceed 256 MB.
</details>
<details>
  <summary>
    <font color="#4fc4f9">What is the maximum dimension of a vector in Milvus?</font>
  </summary>
  Milvus can support vectors with up to 32,768 dimensions.
</details>
## Create/Drop an Index ##
<h4>Create and Drop an Index</h4>
<p>This article provides Python sample codes for creating or dropping indexes.</p>
<h4>Create an index</h4>
<p>Currently, a collection only supports one index type. When you change the index type of a collection, Milvus
  automatically deletes the old index file. Before creating other indexes, a collection uses FLAT as the default index
  type.</p>
<div class="alert note">
  <code>create_index()</code> specifies the index type of a collection and synchronously creates indexes for the
  previously inserted data. When the size of the subsequently inserted data reaches the <code>index_file_size</code>,
  Milvus automatically creates indexes in the background. For streaming data, it is recommended to create indexes before
  inserting the vector so that the system can automatically build indexes for the next data. For static data, it is
  recommended to import all the data at first and then create indexes. See <a
    href="https://github.com/milvus-io/pymilvus/tree/master/examples/indexes">Index Sample Program</a> for details about
  using index.
</div>
<ol>
  <li>
    <p>Prepare the parameters needed to create indexes (take IVF_FLAT as an example). The index parameters are stored in
      a JSON string, which is represented by a dictionary in the Python SDK.</p>
    <pre><code class="language-python">#### Prepare index param.
&gt;&gt;&gt; ivf_param = {'nlist': 16384}
</code></pre>
    <div class="alert note">
      Different index types requires different indexing parameters. They <b>must</b> all have a value.
    </div>
  </li>
  <li>
    <p>Create index for the collection:</p>
    <pre><code class="language-python">#### Create an index.
&gt;&gt;&gt; milvus.create_index('test01', IndexType.IVF_FLAT, ivf_param)
</code></pre>
  </li>
</ol>
<div class="alert note">
  Ensure you enable GPU when indexing and searching with <code>IVF_SQ8H</code>.
</div>
<h4>Drop an Index</h4>
<p>After deleting the index, the collection uses the default index type FLAT again.</p>
<pre><code class="language-python">&gt;&gt;&gt; milvus.drop_index('test01')
</code></pre>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">How to set the value of <code>nlist</code> when I build indexes?</font>
  </summary>
  It depends on your scenario. See <a href="tuning.md#Index">Performance tuning > Index</a> for more information.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Can Milvus create different types of index for different partitions in the same collection?
    </font>
  </summary>
  No. A collection can have only one index type at a time.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Does Milvus create new indexes after vectors are inserted?</font>
  </summary>
  Yes. When the inserted vectors grow to a specified volume, Milvus creates a new segment and starts to create an index
  file for it at the same time. The building of the new index file does not affect the existing index files.
</details>
<h2>Conduct a vector search</h2>
<h4>Conduct a Vector Search</h4>
<p>Milvus supports searching vectors in a collection or partition.</p>
<h4>Search for Vectors in a Collection</h4>
<ol>
  <li>
    <p>Create search parameters. The search parameters are stored in a JSON string, which is represented by a dictionary
      in the Python SDK.</p>
    <pre><code class="language-python">&gt;&gt;&gt; search_param = {'nprobe': 16}
</code></pre>
    <div class="alert note">
      Different index types requires different search parameters. You must <b>assign values</b> to all search
      parameters. See <a href="index.md">Vector Indexes</a> for more information.
    </div>
  </li>
  <li>
    <p>Create random vectors as <code>query_records</code> to search:</p>
    <pre><code class="language-python">#### Create 5 vectors of 256 dimensions.
&gt;&gt;&gt; q_records = [[random.random() for _ in range(256)] for _ in range(5)]
&gt;&gt;&gt; milvus.search(collection_name='test01', query_records=q_records, top_k=2, params=search_param)
</code></pre>
    <div class="alert note">
      <ul>
        <li><code>top_k</code> means searching the k vectors most similar to the target vector. It is defined during the
          search.</li>
        <li>The range of <code>top_k</code> is [1, 16384].</li>
      </ul>
    </div>
  </li>
</ol>
<h4>Search Vectors in a Partition</h4>
<pre><code class="language-python">#### Create 5 vectors of 256 dimensions.
&gt;&gt;&gt; q_records = [[random.random() for _ in range(256)] for _ in range(5)]
&gt;&gt;&gt; milvus.search(collection_name='test01', query_records=q_records, top_k=1, partition_tags=['tag01'], params=search_param)
</code></pre>
<div class="alert note">
  If you do not specify <code>partition_tags</code>, Milvus searches similar vectors in the entire collection.
</div>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">Why is my recall rate unsatisfying?</font>
  </summary>
  You can increase the value of <code>nprobe</code> when searching from a client. The greater the value, the more
  accurate the result, and the more time it takes. See <a href="tuning.md#Index">Performance Tuning > Index</a> for more
  information.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Does Milvus support inserting while searching?</font>
  </summary>
  Yes.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Does the size of a collection affect vector searches in one of its partitions, especially when
      it holds up to 100 million vectors?</font>
  </summary>
  No. If you have specified partitions when conducting a vector search, Milvus searches the specified partitions only.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Does Milvus load the whole collection to the memory if I search only certain partitions in
      that collection?</font>
  </summary>
  No, Milvus only loads the partitions to search.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Are queries in segments processed in parallel?</font>
  </summary>
  <p>Yes. But the parallelism processing mechanism varies with Milvus versions.
  </p>
  <p>
    Suppose a collection has multiple segments, then when a query request comes in:
  <ul>
    <li>CPU-only Milvus processes the segment reading tasks and the segment searching tasks in pipeline.</li>
    <li>On top of the abovementioned pipeline mechanism, GPU-enabled Milvus distributes the segments among the available
      GPUs.</li>
  </ul>
  </p>
  <p>
    See <a href="https://medium.com/unstructured-data-service/how-does-milvus-schedule-query-tasks-2ca38d7bc2f2">How
      Does Milvus Schedule Query Tasks</a> for more information.
  </p>
</details>
<details>
  <summary>
    <font color="#4fc4f9">Will a batch query benefit from multi-threading?</font>
  </summary>
  If your batch query is on a small scale (<code>nq</code>
  < 64), Milvus combines the query requests, in which case multi-threading helps. <p>Otherwise, the resources are
    already exhausted, hence multi-threading does not help much.</p>
</details>
<details>
  <summary>
    <font color="#4fc4f9">Why the search is very slow?</font>
  </summary>
  Check if the value of <code>cache.cache_size</code> in <strong>server_config.yaml</strong> is greater than the size of
  the collection.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Why do I see a surge in memory usage when conducting a vector search immediately after an
      index is created?</font>
  </summary>
  This is because:
  <ul>
    <li>
      <p>Milvus loads the newly created index file to the memory for the vector search.</p>
    </li>
    <li>
      <p>The original vector files used to create the index are not yet released from the memory, because the size of
        original vector files and the index file has not exceeded the upper limit specified by
        <code>cache.cache_size</code>.
      </p>
    </li>
  </ul>
</details>
<details>
  <summary>
    <font color="#4fc4f9">Why does the first search take a long time after Milvus restarts?</font>
  </summary>
  <p>
    This is because, after restarting, Milvus needs to load data from the disk to the memory for the first vector
    search. You can set <code>preload_collection</code> in <strong>server_config.yaml</strong> and load as many
    collections as the memory permits. Milvus loads collections to the memory each time it restarts.
  </p>
  <p>
    Otherwise, you can call <code>load_collection()</code> to load collections to the memory.
  </p>
</details>
<h2>Data Flushing</h2>
<p>When performing operations that change data, you can flush the data in the collection from memory to make the data
  available. Milvus also performs an automatic flush. The automatic flush function flushes all existing collection data
  every a fixed interval (1 second).</p>
<pre><code class="language-python">&gt;&gt;&gt; milvus.flush(collection_name_array=['test01'])
</code></pre>
<div class="alert note">
  After calling <code>delete</code>, you can call <code>flush</code> again to ensure that the newly inserted data is
  visible and the deleted data is no longer recoverable.
</div>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">Why my data cannot be searched immediately after insertion?</font>
  </summary>
  This is because the data has not been flushed from memory to disk. To ensure that data can be searched immediately
  after insertion, you can call <code>flush</code>. However, calling this method too often creates too many small files
  and affects search speed.
</details>
<h2>Compact Segments</h2>
<p>Milvus automatically merges the inserted vector data into segments. A collection can contain multiple segments. After
  deleting some vector data in a segment, the system cannot automatically release the space occupied by the deleted
  vector data. So, you need to compact the segments in the collection to free up extra space.</p>
<pre><code class="language-python">&gt;&gt;&gt; milvus.compact(collection_name='test01', timeout=1)
</code></pre>
<h2>Close the Client</h2>
<p>This article describes how to close a Python client.</p>
<pre><code class="language-python">&gt;&gt;&gt; milvus.close()
</code></pre>
<h1>Reference</h1>
<h2>Milvus Server Configuration</h2>
<h4>Configuration overview</h4>
<p>The configurations apply to both Milvus Standalone and Cluster solutions.</p>
<h5>Milvus file structure</h5>
<p>After successfully starting Milvus server, you can see a Milvus folder at <strong>home/$USER/milvus</strong>, which
  contains the following files:</p>
<ul>
  <li><strong>milvus/db</strong> (database storage)</li>
  <li><strong>milvus/logs</strong> (log storage)</li>
  <li><strong>milvus/conf</strong> (configuration file folder)
    <ul>
      <li><strong>server_config.yaml</strong> (server configuration)</li>
    </ul>
  </li>
</ul>
<h4>Updating configurations</h4>
<h4>Editing the configuration file</h4>
<p>You can directly edit the configuration file. You must restart Milvus every time a configuration file is updated.</p>
<pre><code class="language-shell">$ docker restart &lt;container_id&gt;
</code></pre>
<p>Here we use Milvus’ system configuration file <strong>server_config.yaml</strong> as an example to demonstrate how to
  modify the log level and log path:</p>
<pre><code class="language-YAML">logs:
  level: info
  path: /var/lib/milvus/logs
</code></pre>
<h4>Updating configurations during runtime</h4>
<p>You can update parameters in <strong>server_config.yaml</strong> from a Milvus client. See <a href="sdk.md">Client
    Reference</a> for more information.</p>
<p>Changes to the following parameters take effect immediately without the need to restart Milvus.</p>
<ul>
  <li>Section <code>cache</code>
    <ul>
      <li><code>cache_size</code></li>
      <li><code>insert_buffer_size</code></li>
    </ul>
  </li>
  <li>Section <code>gpu</code>
    <ul>
      <li><code>enable</code></li>
      <li><code>cache_size</code></li>
      <li><code>gpu_search_threshold</code></li>
      <li><code>search_devices</code></li>
      <li><code>build_index_devices</code></li>
    </ul>
  </li>
</ul>
<p>For other parameters, you still need to restart Milvus for the changes to take effect.</p>
<h4><code>server_config.yaml</code> parameters</h4>
<p>Before changing these settings, welcome to consult Milvus team on <a
    href="https://github.com/milvus-io/milvus/issues/new/choose">GitHub issues</a> or <a
    href="https://join.slack.com/t/milvusio/shared_invite/enQtNzY1OTQ0NDI3NjMzLWNmYmM1NmNjOTQ5MGI5NDhhYmRhMGU5M2NhNzhhMDMzY2MzNDdlYjM5ODQ5MmE3ODFlYzU3YjJkNmVlNDQ2ZTk">our
    Slack channel</a>.</p>
<h4>Section <code>cluster</code></h4>
<div class="table-wrapper" markdown="block">
  <table>
    <thead>
      <tr>
        <th>Parameter</th>
        <th>Description</th>
        <th>Type</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>enable</code></td>
        <td>Whether to enable cluster mode. <ul>
            <li><code>true</code>: Enable cluster mode.</li>
            <li><code>false</code>: Disable cluster mode.</li>
          </ul>
        </td>
        <td>Boolean</td>
        <td><code>false</code></td>
      </tr>
      <tr>
        <td><code>role</code></td>
        <td>Milvus deployment role: <ul>
            <li><code>rw</code>: Read and write.</li>
            <li><code>ro</code>: Read only.</li>
          </ul>
        </td>
        <td>Role</td>
        <td><code>rw</code></td>
      </tr>
    </tbody>
  </table>
</div>
<h4>Section <code>general</code></h4>
<div class="table-wrapper" markdown="block">
  <table>
    <thead>
      <tr>
        <th>Parameter</th>
        <th>Description</th>
        <th>Type</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>timezone</code></td>
        <td>Uses UTC-x or UTC+x to specify a time zone. For example, use UTC+8 to represent China Standard Time.</td>
        <td>Timezone</td>
        <td><code>UTC+8</code></td>
      </tr>
      <tr>
        <td><code>meta_uri</code></td>
        <td>URI for metadata storage, using SQLite (for single server Milvus) or MySQL (for distributed cluster Milvus).
          Format: <code>dialect://username:password@host:port/database</code>. <code>dialect</code> can be either
          <code>sqlite</code> or <code>mysql</code>. Replace the other fields with real values.
        </td>
        <td>URI</td>
        <td><code>sqlite://:@:/</code></td>
      </tr>
    </tbody>
  </table>
</div>
<h4>Section <code>network</code></h4>
<div class="table-wrapper" markdown="block">
  <table>
    <thead>
      <tr>
        <th>Parameter</th>
        <th>Description</th>
        <th>Type</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>bind.address</code></td>
        <td>IP address that Milvus server monitors.</td>
        <td>IP</td>
        <td><code>0.0.0.0</code></td>
      </tr>
      <tr>
        <td><code>bind.port</code></td>
        <td>Port that Milvus server monitors. Range: [1025, 65534].</td>
        <td>Integer</td>
        <td><code>19530</code></td>
      </tr>
      <tr>
        <td><code>http.enable</code></td>
        <td>Whether to enable HTTP server. <ul>
            <li><code>true</code>: Enable HTTP server.</li>
            <li><code>false</code>: Disable HTTP server.</li>
          </ul>
        </td>
        <td>Boolean</td>
        <td><code>true</code></td>
      </tr>
      <tr>
        <td><code>http.port</code></td>
        <td>Port that Milvus HTTP server monitors. Range: [1025, 65534].</td>
        <td>Integer</td>
        <td><code>19121</code></td>
      </tr>
    </tbody>
  </table>
</div>
<h4>Section <code>storage</code></h4>
<div class="table-wrapper" markdown="block">
  <table>
    <thead>
      <tr>
        <th>Parameter</th>
        <th>Description</th>
        <th>Type</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>path</code></td>
        <td>path to Milvus data files, including vector data files, index files, and the metadata.</td>
        <td>Path</td>
        <td><code>/var/lib/milvus</code></td>
      </tr>
      <tr>
        <td><code>auto_flush_interval</code></td>
        <td>The interval, in seconds, at which Milvus automatically flushes data to disk. Range: [0, 3600].
          <code>0</code> means disabling the regular flush.
        </td>
        <td>Integer</td>
        <td><code>1</code></td>
      </tr>
    </tbody>
  </table>
</div>
<h4>Section <code>wal</code></h4>
<div class="table-wrapper" markdown="block">
  <table>
    <thead>
      <tr>
        <th>Parameter</th>
        <th>Description</th>
        <th>Type</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>enable</code></td>
        <td>Whether to enable write-ahead logging (WAL) in Milvus. If enabled, Milvus writes all data changes to log
          files in advance before implementing data changes. WAL ensures the atomicity and durability for Milvus
          operations.<ul>
            <li><code>true</code>: Enable WAL.</li>
            <li><code>false</code>: Disable WAL.</li>
          </ul>
        </td>
        <td>Boolean</td>
        <td>true</td>
      </tr>
      <tr>
        <td><code>recovery_error_ignore</code></td>
        <td>Whether to ignore logs with errors that happens during WAL recovery. <ul>
            <li><code>true</code>: Ignore errors in log files during WAL recovery.</li>
            <li><code>false</code>: Milvus fails to restart if log files have any error.</li>
          </ul>
        </td>
        <td>Boolean</td>
        <td>true</td>
      </tr>
      <tr>
        <td><code>buffer_size</code></td>
        <td>Total size of the read and write WAL buffer in Bytes. Range: 64MB ~ 4096MB. If the value you specified is
          out of range, Milvus automatically uses the boundary value closest to the specified value. It is recommended
          you set <code>buffer_size</code> to a value greater than the inserted data size of a single insert operation
          for better performance.</td>
        <td>String</td>
        <td><code>256MB</code></td>
      </tr>
      <tr>
        <td><code>wal_path</code></td>
        <td>path to WAL log files.</td>
        <td>String</td>
        <td><code>/var/lib/milvus/wal</code></td>
      </tr>
    </tbody>
  </table>
</div>
<h4>Section <code>cache</code></h4>
<div class="table-wrapper" markdown="block">
  <table>
    <thead>
      <tr>
        <th>Parameter</th>
        <th>Description</th>
        <th>Type</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>cache_size</code></td>
        <td>The size of the CPU memory for caching data for faster query. The sum of <code>cache_size</code> and
          <code>insert_buffer_size</code> must be less than the system memory size.
        </td>
        <td>String</td>
        <td><code>4GB</code></td>
      </tr>
      <tr>
        <td><code>insert_buffer_size</code></td>
        <td>Buffer size used for data insertion. The sum of <code>insert_buffer_size</code> and <code>cache_size</code>
          must be less than the system memory size.</td>
        <td>String</td>
        <td><code>1GB</code></td>
      </tr>
      <tr>
        <td><code>preload_collection</code></td>
        <td>A comma-separated list of collection names to load when Milvus server starts up. <ul>
            <li><code>'*'</code> means preload all existing tables (single-quote or double-quote required).For example:
              <code>preload_collection='*'</code>.
            </li>
            <li>To load specific collections, list the collection names that need to be loaded (enclose each collection
              name with single-quote or double-quote, and separate adjacent collections with a comma). For example:
              <code>preload_collection=['collection1','collection2']</code>.
            </li>
          </ul>
        </td>
        <td>StringList</td>
        <td>N/A</td>
      </tr>
    </tbody>
  </table>
</div>
<h4>Section <code>gpu</code></h4>
<p>This section determines whether to enable GPU support/usage in Milvus. GPU support, which uses both CPU and GPUs for
  optimized resource utilization, can achieve accelerated search performance on very large datasets.</p>
<div class="table-wrapper" markdown="block">
  <table>
    <thead>
      <tr>
        <th>Parameter</th>
        <th>Description</th>
        <th>Type</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>enable</code></td>
        <td>Whether to enable GPU usage in Milvus. <ul>
            <li><code>true</code>: Enable GPU usage.</li>
            <li><code>false</code>: Disable GPU usage.</li>
          </ul>
        </td>
        <td>Boolean</td>
        <td><code>false</code></td>
      </tr>
      <tr>
        <td><code>cache_size</code></td>
        <td>Size of the GPU memory for caching data. It must be less than the total memory size of the graphics card.
        </td>
        <td>String</td>
        <td><code>1GB</code></td>
      </tr>
      <tr>
        <td><code>gpu_search_threshold</code></td>
        <td>The threshold of GPU search. If <code>nq</code> represents the number of vectors to be searched for a single
          batch of queries, the search stragety is as follows: <ul>
            <li><code>nq</code> ≥ <code>gpu_search_threshold</code>: The search will be executed on GPUs only.</li>
            <li><code>nq</code> &lt; <code>gpu_search_threshold</code>: The search will be executed on both CPUs and
              GPUs.</li>
          </ul>
        </td>
        <td>Integer</td>
        <td><code>1000</code></td>
      </tr>
      <tr>
        <td><code>search_devices</code></td>
        <td>A list of GPU devices used for search computation. Must be in format: <code>gpux</code>, where
          <code>x</code> is the GPU number, such as <code>gpu0</code>.
        </td>
        <td>DeviceList</td>
        <td><code>gpu0</code></td>
      </tr>
      <tr>
        <td><code>build_index_devices</code></td>
        <td>A list of GPU devices used for index building. Must be in format: <code>gpux</code>, where <code>x</code> is
          the GPU number, such as <code>gpu0</code>.</td>
        <td>DeviceList</td>
        <td><code>gpu0</code></td>
      </tr>
    </tbody>
  </table>
</div>
<div class="alert note">
  In Milvus, index building and search computation are separate processes, which can be executed on CPU, GPU, or both.
  You can assign index building and search computation to multiple GPUs by adding GPUs under <code>search_devices</code>
  or <code>build_index_devices</code>. See the following YAML sample code:
</div>
<pre><code class="language-yaml">    search_devices:
      - gpu0
      - gpu1
    build_index_devices:
      - gpu0
      - gpu1
</code></pre>
<h4>Section <code>logs</code></h4>
<div class="table-wrapper" markdown="block">
  <table>
    <thead>
      <tr>
        <th>Parameter</th>
        <th>Description</th>
        <th>Type</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>level</code></td>
        <td>Log level in Milvus. Log Levels: <code>debug</code> &lt; <code>info</code> &lt; <code>warning</code> &lt;
          <code>error</code> &lt; <code>fatal</code>.
        </td>
        <td>String</td>
        <td><code>debug</code></td>
      </tr>
      <tr>
        <td><code>trace.enable</code></td>
        <td>Whether to enable trace level logging. <ul>
            <li><code>true</code>: Enable trace level logging.</li>
            <li><code>false</code>: Disable trace level logging.</li>
          </ul>
        </td>
        <td>Boolean</td>
        <td><code>true</code></td>
      </tr>
      <tr>
        <td><code>path</code></td>
        <td>Absolute path to the folder holding the log files.</td>
        <td>String</td>
        <td><code>/var/lib/milvus/logs</code></td>
      </tr>
      <tr>
        <td><code>max_log_file_size</code></td>
        <td>The maximum size of each log file. Range: 512MB ~ 4096MB.</td>
        <td>String</td>
        <td><code>1024MB</code></td>
      </tr>
      <tr>
        <td><code>log_rotate_num</code></td>
        <td>The maximum number of log files that Milvus keeps for each logging level. Range: [0, 1024]. <code>0</code>
          means that the number of stored log files does not have an upper limit.</td>
        <td>Integer</td>
        <td><code>0</code></td>
      </tr>
    </tbody>
  </table>
</div>
<h4>Section <code>metric</code></h4>
<div class="table-wrapper" markdown="block">
  <table>
    <thead>
      <tr>
        <th>Parameter</th>
        <th>Description</th>
        <th>Type</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>enable</code></td>
        <td>Whether to enable the monitoring function of Prometheus. <ul>
            <li><code>true</code>: Enable monitoring function.</li>
            <li><code>false</code>: Disable monitoring function.</li>
          </ul>
        </td>
        <td>Boolean</td>
        <td><code>false</code></td>
      </tr>
      <tr>
        <td><code>address</code></td>
        <td>IP address of Prometheus Pushgateway.</td>
        <td>IP</td>
        <td><code>127.0.0.1</code></td>
      </tr>
      <tr>
        <td><code>port</code></td>
        <td>Port of Prometheus Pushgateway. Range: [1025, 65534].</td>
        <td>Integer</td>
        <td><code>9091</code></td>
      </tr>
    </tbody>
  </table>
</div>
<div class="alert note" id="size">
  In the Milvus configuration file, space size should be written in the format of "number+unit", such as "4GB".
  <ul>
    <li>Do not add a space between the number and its unit.</li>
    <li>The number must be an integer.</li>
    <li>Available units include GB, MB, and KB.</li>
  </ul>
</div>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">Besides the configuration file, how can I tell Milvus is using GPU for search?</font>
  </summary>
  <p>Use any of the following methods:
  <ul>
    <li>Use <code>nvidia-smi</code> to monitor your GPU usage.</li>
    <li>
      Use Prometheus to monitor performance metrics. See <a href="setup_grafana.md#System-performance-metrics">Visualize
        Metrics in Grafana > System performance metrics</a>.
    </li>
    <li>Check the Milvus server logs.</li>
  </ul>
  </p>
</details>
<details>
  <summary>
    <font color="#4fc4f9">If I have set <code>preload_collection</code>, does Milvus service start only after all
      collections are loaded to the memory?</font>
  </summary>
  Yes. If you have set <code>preload_collection</code> in <strong>server_config.yaml</strong>, Milvus' service is not
  available until it loads all specified collections.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Why is my GPU always idle?</font>
  </summary>
  <p>It is very likely that Milvus is using CPU for query. If you want to use GPU for query, you need to set the value
    of <code>gpu_search_threshold</code> in <strong>server_config.yaml</strong> to be less than <code>nq</code> (number
    of vectors per query).
  </p>
  <p>
    You can use <code>gpu_search_threshold</code> to set the threshold: when <code>nq</code> is less than this value,
    Milvus uses CPU for queries; otherwise, Milvus uses GPU instead.
  </p>
  <p>
    We do not recommend enabling GPU when the query number is small.
  </p>
</details>
<details>
  <summary>
    <font color="#4fc4f9">Why is the time in the log files different from the system time?</font>
  </summary>
  The log files in the Docker container use UTC time by default. If your host machine does not use UTC time, then the
  time in the log files is different. We recommend that you mount the log files onto your host machine to keep the time
  consistent between the log and the host.
</details>
<h2>Manage metadata with MySQL</h2>
<h4>Manage Metadata with MySQL</h4>
<p>By default, Milvus uses SQLite for metadata management because it is easy to use, robust, and requires no additional
  services. However, we still recommend using MySQL in a production environment for improved reliability.</p>
<div class="alert warning">
  In CentOS, Milvus does not support MySQL 8.0 or higher.
</div>
<p>Follow the steps below to use MySQL as metadata management service in Linux:</p>
<ol>
  <li>
    <p>Pull the latest image of MySQL:</p>
    <pre><code class="language-shell">$ docker pull mysql:5.7
</code></pre>
  </li>
  <li>
    <p>Launch MySQL service. You can set your own password and port.</p>
    <pre><code class="language-shell">$ docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7
</code></pre>
  </li>
  <li>
    <p>Use root account and the IP of the host that runs MySQL service (<code>&lt;MySQL_server_host IP&gt;</code>) to
      log in MySQL. Press &lt;ENTER&gt; to enter the password you set in the previous step.</p>
    <pre><code class="language-shell">$ mysql -h&lt;MySQL_server_host IP&gt; -uroot -p
</code></pre>
  </li>
  <li>
    <p>Enter MySQL client command line interface to create a database. Here we use <code>milvus</code> as the database
      name.</p>
    <pre><code class="language-sql">mysql&gt; create database milvus;
</code></pre>
  </li>
  <li>
    <p>Quit MySQL client and update the <code>meta_uri</code> parameter in <strong>server_config.yaml</strong>. Use the
      IP of the host that runs MySQL service (<code>&lt;MySQL_server_host IP&gt;</code>). Note that the password, IP
      address, port, and database name must be consistent with your previous settings.</p>
    <pre><code class="language-yaml">meta_uri: mysql://root:123456@&lt;MySQL_server_host IP&gt;:3306/milvus
</code></pre>
  </li>
  <li>
    <p>Use the updated <strong>server_config.yaml</strong> to launch Milvus.</p>
  </li>
</ol>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">Why does Milvus return <code>database is locked</code>?</font>
  </summary>
  If you use SQLite to manage metadata, you receive this error message when write requests occur frequently. We
  recommend using MySQL for metadata management. See <a href="data_manage.md">Manage Metadata with MySQL</a> for more
  information.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Why can't I find vectors on SQLite or MySQL?</font>
  </summary>
  Milvus stores vectors and indexes directly in the disk as files, not in SQLite or MySQL. It uses SQLite or MySQL to
  store metadata of the vectors instead. See <a href="storage_concept.md">Storage Concepts</a> for more information.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Can I use SQL Server or PostgreSQL to store metadata in Milvus?</font>
  </summary>
  No, we only support storing metadata using SQLite or MySQL.
</details>
<h4>Related blogs</h4>
<p>From data import, data storage to data querying and scheduling, our blogs on Medium provide detailed insights into
  the data management mechanism of Milvus.</p>
<ul>
  <li><a href="https://medium.com/@milvusio/managing-data-in-massive-scale-vector-search-engine-db2e8941ce2f">Managing
      Data in Massive-Scale Vector Database</a></li>
  <li><a href="https://github.com/milvus-io/community/blob/master/blog/en/2019-12-18-datafile-cleanup.md">Improvements
      of the Data File Cleanup Mechanism</a></li>
  <li><a href="https://medium.com/@milvusio/milvus-metadata-management-1-6b9e05c06fb0">Viewing Metadata</a></li>
  <li><a
      href="https://medium.com/@milvusio/milvus-metadata-management-2-fields-in-the-metadata-table-3bf0d296ca6d">Fields
      in Metadata Tables</a></li>
  <li><a href="https://medium.com/@milvusio/milvus-metadata-management-3-e65b14137f58">How to Manage Data Files with
      Metadata</a></li>
</ul>
<h2>Monitoring and Alerting</h2>
<h3>Overview</h3>
<h4>Monitoring and Alerting</h4>
<p>It is critical to actively monitor the overall performance of a system running in production, and to create alerting
  rules that promptly send notifications when there are events that require investigation or intervention.</p>
<p>Milvus uses the following monitoring and alerting solutions:</p>
<ul>
  <li>
    <p>Prometheus to store and monitor its metrics:</p>
    <ul>
      <li>Prometheus server which scrapes and stores time series data.</li>
      <li>Client libraries for instrumenting monitoring metrics.</li>
      <li>Pushgateway to push metric data and ensure short-lived monitoring metrics, which may not be scraped in time,
        to be exposed to Prometheus.</li>
      <li>Alertmanager for alert handling.</li>
    </ul>
  </li>
  <li>
    <p>Grafana, an open source platform for time-series analytics, to visualize various performance metrics.</p>
  </li>
</ul>
<h4>Workflow</h4>
<p>Milvus collects monitoring data and pushes it to Pushgateway. At the same time, the Prometheus server periodically
  pulls data from Pushgateway and saves it to its time-series database. The following graph shows how Prometheus works
  in Milvus:</p>
<p><img src="../../../../assets/monitoring/monitoring.png" alt="proxy"></p>
<h3>Start up Prometheus</h3>
<h4>Configure and Start Prometheus</h4>
<p>This page describes how to configure and start up <a href="https://prometheus.io/">Prometheus</a>, and how to connect
  <a href="https://prometheus.io/docs/alerting/alertmanager/">Alertmanager</a> to Prometheus for metrics visualization
  and early warning purposes.
</p>
<h4>Install Prometheus</h4>
<ol>
  <li>
    <p>Download the <a href="https://prometheus.io/download/">Prometheus tarball</a> for your operating system.</p>
  </li>
  <li>
    <p>Go to the directory holding the Prometheus file, and ensure that Prometheus is properly installed:</p>
    <pre><code class="language-shell">$ ./prometheus --version
</code></pre>
    <div class="alert note">
      You can add the path to Prometheus to <code>PATH</code>. This makes it easy to start Prometheus from any shell.
    </div>
  </li>
</ol>
<h4>Configure and start Prometheus</h4>
<ol>
  <li>
    <p>Start Pushgateway:</p>
    <pre><code class="language-shell">./pushgateway
</code></pre>
    <div class="alert warning">
      You <i>must</i> start Pushgateway before starting the Milvus Server.
    </div>
  </li>
  <li>
    <p>Start the Prometheus monitor in <strong>server_config.yaml</strong> and set the address and port number of
      Pushgateway:</p>
    <pre><code class="language-yaml">metric:
  enable: true                 #### Set the value to true to enable the Prometheus monitor.
  address: &lt;your_IP_address&gt;   #### Set the IP address of Pushgateway.
  port: 9091                   #### Set the port number of Pushgateway.
</code></pre>
    <div class="alert note">
      In the Kubernetes cluster, you need to set the <b>server_config.yaml</b> for each node to monitor.
    </div>
  </li>
  <li>
    <p>Go to the Prometheus root directory, and download starter <a
        href="https://github.com/milvus-io/docs/blob/master/v1.1.0/assets/monitoring/prometheus.yml">Prometheus
        configuration file</a> for Milvus:</p>
    <pre><code class="language-shell">$ wget https://raw.githubusercontent.com/milvus-io/docs/master/v1.1.0/assets/monitoring/prometheus.yml \ -O prometheus.yml
</code></pre>
  </li>
  <li>
    <p>Download starter <a
        href="https://github.com/milvus-io/docs/blob/master/v1.1.0/assets/monitoring/alert_rules.yml">alerting rules</a>
      for Milvus to the Prometheus root directory:</p>
    <pre><code class="language-shell">wget -P rules https://raw.githubusercontent.com/milvus-io/docs/master/v1.1.0/assets/monitoring/alert_rules.yml
</code></pre>
  </li>
  <li>
    <p>Edit the Prometheus configuration file according to your needs:</p>
    <ul>
      <li><code>global</code>: Configures parameters such as <code>scrape_interval</code> and
        <code>evaluation_interval</code>.
      </li>
    </ul>
    <pre><code class="language-yaml">global:
  scrape_interval:     2s #### Set the crawl time interval to 2s.
  evaluation_interval: 2s #### Set the evaluation interval to 2s.
</code></pre>
    <ul>
      <li><code>alerting</code>: Sets the address and port of Alertmanager.</li>
    </ul>
    <pre><code class="language-yaml">alerting:
alertmanagers:
- static_configs:
   - targets: ['localhost:9093']
</code></pre>
    <ul>
      <li><code>rule_files</code>: Specifies the file that defines the alerting rules.</li>
    </ul>
    <pre><code class="language-yaml">rule_files:
   - &quot;alert_rules.yml&quot;
</code></pre>
    <ul>
      <li><code>scrape_configs</code>: Sets <code>job_name</code> and <code>targets</code> for scraping data.</li>
    </ul>
    <pre><code class="language-yaml">scrape_configs:
- job_name: 'prometheus'
   static_configs:
   - targets: ['localhost:9090']

- job_name: 'pushgateway'
   honor_labels: true
   static_configs:
   - targets: ['localhost:9091']
</code></pre>
    <div class="alert note">
      See <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/">Prometheus
        Configuration</a> for more information about the configuration file of Prometheus.
    </div>
  </li>
  <li>
    <p>Start Prometheus:</p>
    <pre><code class="language-shell">./prometheus --config.file=prometheus.yml
</code></pre>
  </li>
</ol>
<p><em>After starting up Prometheus, you can display and render on its interface the metrics that Milvus provides. See
    <a href="milvus_metrics.md">Milvus Metrics</a> for more information.</em></p>
<h4>Configure Alertmanager</h4>
<h4>Events to create alert rules</h4>
<p>Proactively monitoring metrics contributes to identification of emerging issues. Creating alerting rules for events
  requiring immediate intervention is essential as well.</p>
<p>This section includes the most important events for which you must create alerting rules.</p>
<p><strong>Server is down</strong></p>
<ul>
  <li>Rule: Send an alert when the Milvus server is down.</li>
  <li>How to detect: If the Milvus server is down, <strong>No Data</strong> is displayed for various metrics on the
    monitoring dashboard.</li>
</ul>
<p><strong>CPU/GPU temperature is too high</strong></p>
<ul>
  <li>Rule: Send an alert when the CPU/GPU temperature exceeds 80 degrees Celsius.</li>
  <li>How to detect: Check the metrics <code>CPU Temperature</code> and <code>GPU Temperature</code> on the monitoring
    dashboard.</li>
</ul>
<h4>Configuration steps</h4>
<ol>
  <li>
    <p>Download the <a href="https://prometheus.io/download/#alertmanager">latest Alertmanager tarball</a> for your
      operating system.</p>
  </li>
  <li>
    <p>Ensure that Alertmanager is properly installed:</p>
    <pre><code class="language-shell">$ alertmanager --version
</code></pre>
    <div class="alert note">
      You can add the path to Alertmanager to <code>PATH</code>. This makes it easy to start Alertmanager from any
      shell.
    </div>
  </li>
  <li>
    <p>Create the <a href="https://prometheus.io/docs/alerting/configuration/">Alertmanager configuration file</a> to
      specify the desired receivers for notifications, and add it to Alertmanager root directory.</p>
  </li>
  <li>
    <p>Start the Alertmanager server, with the <code>--config.file</code> flag pointing to the configuration file:</p>
    <pre><code class="language-shell">alertmanager --config.file=alertmanager.yml
</code></pre>
  </li>
  <li>
    <p>Use your browser to open http://&lt;hostname of machine running alertmanager&gt;:9093, and use the Alertmanager
      UI to define rules for <a href="https://prometheus.io/docs/alerting/alertmanager/#silences">muting alerts</a>.</p>
  </li>
</ol>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">How can I differentiate if I have multiple Milvus nodes connected to Pushgateway?</font>
  </summary>
  You can add a Prometheus instance in <strong>prometheus.yaml</strong>. Then Prometheus or Granafa will show the
  monitoring data, as well as the source node.
</details>
<h3>Visualize Metrics in Grafana</h3>
<h4>Configure and start Grafana</h4>
<ol>
  <li>
    <p>Start Grafana:</p>
    <pre><code class="language-shell">$ docker run -i -p 3000:3000 grafana/grafana
</code></pre>
  </li>
  <li>
    <p>Use your browser to open http://&lt;hostname of machine running grafana&gt;:3000 and log into the Grafana UI.</p>
  </li>
</ol>
<div class="alert note">
  Grafana's default username and password are both <code>admin</code>. You can create a Grafana account of your own.
</div>
<ol start="3">
  <li>
    <p><a href="https://grafana.com/docs/grafana/latest/features/datasources/add-a-data-source/">Add Prometheus as a
        data source</a>.</p>
  </li>
  <li>
    <p>In Grafana UI, click <strong>Configuration &gt; Data Sources &gt; Prometheus</strong>, and configure the data
      source as follows:</p>
    <table>
      <thead>
        <tr>
          <th style="text-align:left">Field</th>
          <th style="text-align:left">Definition</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align:left">Name</td>
          <td style="text-align:left">Prometheus</td>
        </tr>
        <tr>
          <td style="text-align:left">Default</td>
          <td style="text-align:left"><code>True</code></td>
        </tr>
        <tr>
          <td style="text-align:left">URL</td>
          <td style="text-align:left">http://&lt;hostname of machine running prometheus&gt;:9090</td>
        </tr>
        <tr>
          <td style="text-align:left">Access</td>
          <td style="text-align:left">Browser</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>Download the starter <a
        href="https://github.com/milvus-io/docs/blob/master/v1.1.0/assets/monitoring/dashboard.json">Grafana
        dashboard</a> for Milvus:</p>
  </li>
  <li>
    <p><a href="http://docs.grafana.org/reference/export_import/#importing-a-dashboard">Add the dashboard to
        Grafana</a>.</p>
    <p><img src="../../../../assets/prometheus.png" alt="prometheus.png"></p>
  </li>
</ol>
<h4>Display and Render Milvus Metrics</h4>
<p>You can use <a href="https://github.com/milvus-io/docs/blob/master/v1.1.0/assets/monitoring/dashboard.json">Grafana
    dashboard</a> to determine how to display and render Milvus metrics. See <a href="milvus_metrics.md">Milvus
    Metrics</a> for more information.</p>
<h3>Milvus Metrics</h3>
<p>Milvus outputs detailed time-series metrics during runtime. You can use <a
    href="https://prometheus.io/">Prometheus</a>, <a href="https://grafana.com/">Grafana</a>, or any visualization tool
  that you think appropriate to display and render the following metrics:</p>
<ul>
  <li>Milvus Performance Metrics</li>
  <li>System Performance Metrics: Metrics relating to CPU/GPU usage, network traffic, and disk read speed.</li>
  <li>Hardware Storage Metrics: Metrics relating to data size, data files, and storage capacity.</li>
</ul>
<h4>Milvus performance metrics</h4>
<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Insert per Second</strong></td>
      <td>Number of vectors that are inserted in a second. (Real-time display)</td>
    </tr>
    <tr>
      <td><strong>Queries per Minute</strong></td>
      <td>Number of queries that are run in a minute. (Real-time display)</td>
    </tr>
    <tr>
      <td><strong>Query Time per Vector</strong></td>
      <td>Average time to query one vector. Divide the query elapsed time by the number of queried vectors.</td>
    </tr>
    <tr>
      <td><strong>Query Service Level</strong></td>
      <td>Query service level = n_queries_completed_within_threshold1 / n_queries <br />Generally, it is recommended to
        set 3 time periods - threshold1, threshold2, and threshold3, to track the query service level.</td>
    </tr>
    <tr>
      <td><strong>Uptime</strong></td>
      <td>How long Milvus has been running. (Minutes)</td>
    </tr>
  </tbody>
</table>
<h4>System performance metrics</h4>
<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>GPU Utilization</strong></td>
      <td>GPU utilization ratio (%).</td>
    </tr>
    <tr>
      <td><strong>GPU Memory Usage</strong></td>
      <td>GPU memory (GB) currently consumed by Milvus.</td>
    </tr>
    <tr>
      <td><strong>CPU Utilization</strong></td>
      <td>CPU utilization ratio (%). Divide the time that the server is busy by the total elapsed time.</td>
    </tr>
    <tr>
      <td><strong>Memory Usage</strong></td>
      <td>Memory (GB) currently consumed by Milvus.</td>
    </tr>
    <tr>
      <td><strong>Cache Utilization</strong></td>
      <td>Cache utilization ratio (%).</td>
    </tr>
    <tr>
      <td><strong>Network IO</strong></td>
      <td>Network IO read/write speed (GB/s).</td>
    </tr>
    <tr>
      <td><strong>Disk Read Speed</strong></td>
      <td>Disk read speed (GB/s).</td>
    </tr>
    <tr>
      <td><strong>Disk Write Speed</strong></td>
      <td>Disk write speed (GB/s).</td>
    </tr>
  </tbody>
</table>
<h4>Hardware storage metrics</h4>
<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Data Size</strong></td>
      <td>Total amount (GB) of data stored in Milvus.</td>
    </tr>
    <tr>
      <td><strong>Total File</strong></td>
      <td>Number of data files currently stored in Milvus.</td>
    </tr>
  </tbody>
</table>
<h2>Performance Tuning</h2>
<h4>Performance tuning</h4>
<h4>Tune insertion performance</h4>
<div class="alert note">
  See <a href="storage_operation.md">Storage Operations</a> for the basic procedure from inserting data to writing data
  to disk.
</div>
<p>If the amount of data is less than the upper limit of a single insertion (256 MB), batch insertion is much more
  efficient than a single insertion.</p>
<p>The following parameters in the system configuration file have an impact on the insertion performance:</p>
<ul>
  <li><code>wal.enable</code></li>
</ul>
<p>This parameter is used to enable or disable the <a href="write_ahead_log.md">Write Ahead Log (WAL)</a> function
  (enabled by default). The processes of inserting data when write ahead log is enabled or disabled are as follows:</p>
<ul>
  <li>When write ahead log is enabled, the write ahead log module writes data to the disk, and then turns to the insert
    operation.</li>
  <li>When write ahead log is disabled, the data insertion speed is faster. The system directly writes the data to the
    mutable buffer in the memory and immediately turns to the insert operation.</li>
</ul>
<p><code>delete</code> operations are faster when write ahead log is enabled. We recommend that you enable write ahead
  log to ensure reliability of your data.</p>
<ul>
  <li><code>storage.auto_flush_interval</code></li>
</ul>
<p>This parameter (1 second by default) refers to the interval time of the data flushing task in the background.
  Increasing this value can reduce the number of segment merges, reduce disk I/O, and increase the throughput rate of
  insert operations.</p>
<div class="alert note">
  Milvus cannot search for data that has not been flushed within this time interval.
</div>
<p>Besides, the parameter <code>index_file_size</code>, which is used when creating collections, has an impact on the
  insertion performance. The value of this parameter is 1024 MB by default and 4096 MB at most. The larger the
  <code>index_file_size</code>, the more time it takes to merge data to the size set by this parameter, which affects
  the throughput rate of the insert operation. The smaller the parameter, the more data segments are generated. This may
  worsen query performance.
</p>
<p>Besides software-level elements, network bandwidth and storage media also play a role in the insertion performance.
</p>
<h4>Tune query performance</h4>
<p>Factors that affect query performance include hardware environment, system parameters, indexes, and query scale.</p>
<h4>Hardware environment</h4>
<ul>
  <li>When CPU is used for calculations, query performance depends on the CPU’s frequency, number of cores, and
    supported instruction set.</li>
</ul>
<div class="alert note">
  Milvus has better query performance on CPUs that support the AVX instruction set.
</div>
<ul>
  <li>When GPU is used for calculations, query performance depends on the GPU’s parallel computing capabilities and
    transmission bandwidth.</li>
</ul>
<h4>System parameters</h4>
<div class="alert note">
  See <a href="milvus_config.md">Milvus server configuration</a> for information about how to configure system
  parameters.
</div>
<ul>
  <li><code>cache.cache_size</code></li>
</ul>
<p>This parameter (4 GB by default) refers to the size of the cache space used for resident query data. If the cache
  space is insufficient to hold the required data, the data will be temporarily loaded from the disk during the query,
  which seriously affects query performance. Therefore, <code>cache_size</code> should be greater than the amount of
  data required by the query.</p>
<ul>
  <li>The data size of the floating-point original vector can be estimated by “total number of vectors × dimension × 4”.
  </li>
  <li>The data size of the binary type original vector can be estimated by “total number of vectors × dimension ÷ 8”.
  </li>
</ul>
<p>After the indexes are created (FLAT is not included), the index files require additional disk space and the query
  only needs to load the index files.</p>
<ul>
  <li>The data volume of the IVF_FLAT index is basically equal to the total data volume of its original vectors.</li>
  <li>The data volume of the IVF_SQ8 / IVF_SQ8H index is equivalent to 25% to 30% of the total data volume of the
    original vectors.</li>
  <li>The data volume of the IVF_PQ index changes according to its parameters, which is generally lower than 10% of the
    total data volume of the original vectors.</li>
  <li>The data volume of HNSW/RNSG/Annoy index is greater than the total data volume of the original vectors.</li>
</ul>
<div class="alert note">
  By calling <code>get_collection_stats</code>, you can get the total amount of data required to query a collection.
</div>
<ul>
  <li><code>gpu.gpu_search_threshold</code></li>
</ul>
<p>In the GPU version, GPU is enabled for query when the number of target vectors is greater than or equals to the
  <code>gpu_search_threshold</code> (1000 by default).
</p>
<p>The performance of GPU queries depends on GPU and the speed at which the CPU loads data to the graphic memory. The
  advantages of parallel computing with GPUs cannot be fully utilized when processing a small number of target vectors.
  Only when the number of target vectors reaches a certain threshold, the query performance on GPUs will be better than
  on CPUs. In practice, the ideal value of this parameter can be obtained based on experimental comparison.</p>
<ul>
  <li><code>gpu.resource_resources</code></li>
</ul>
<p>Specifies the GPU devices used for querying. For scenarios with a large number of query target vectors, using
  multiple GPUs can significantly improve query efficiency.</p>
<ul>
  <li><code>gpu.build_index_resources</code></li>
</ul>
<p>Specifies the GPU devices used for indexing. For scenarios where data insertion and querying are concurrent, you can
  use GPUs to build indexes to avoid the index building task competing for CPU resources with the query task.</p>
<h4>Index</h4>
<div class="alert note">
  See <a href="index.md">Index Overview</a> for the basic concepts of vector index.
</div>
<p>To choose the right index, you need to trade off between multiple indicators such as storage space, query
  performance, and query recall rate.</p>
<ul>
  <li>FLAT index</li>
</ul>
<p>FLAT is a brute-force search for vectors. It has the slowest search speed, but has the highest recall rate (100%) and
  takes up the smallest amount of disk space.</p>
<p>As the number of target vectors increases, the time spent on using CPUs to perform FLAT queries increases linearly.
  On the other hand, using GPU to perform FLAT queries guarantees the high efficiency of batch queries and little effect
  on the query time from the increasing number of target vectors.</p>
<ul>
  <li>IVF Indexes</li>
</ul>
<p>IVF indexes include IVF_FLAT, IVF_SQ8 / IVF_SQ8H, and IVF_PQ. The IVF_SQ8 / IVF_SQ8H and IVF_PQ indexes perform lossy
  compression on vector data to reduce the disk space occupied by index files.</p>
<p>All IVF indexes have two parameters: <code>nlist</code> and <code>nprobe</code>. <code>nlist</code> is the indexing
  parameter, <code>nprobe</code> the searching parameter. For more information about the recommended values, see <a
    href="performance_faq.md">Performance FAQ &gt; How to set <code>nlist</code> and <code>nprobe</code> for IVF
    indexes?</a>.</p>
<p>The following section provides formulae for estimating the calculation amount for queries on IVF indexes:</p>
<ul>
  <li>The amount of calculation of a single segment = the number of target vectors × (<code>nlist</code> + (the number
    of vectors in a segment ÷ <code>nlist</code>) × <code>nprobe</code>)</li>
  <li>The number of segments = the total amount of aggregate data ÷ <code>index_file_size</code></li>
  <li>The total amount of calculation of a collection = the amount of calculation of a single segment × the segment
    number</li>
</ul>
<p>The larger the estimated total amount of calculation, the longer the query takes. In practice, you can get reasonable
  parameters through the above formulas, which provides high query performance under the premise of an acceptable recall
  rate.</p>
<div class="alert note">
  In scenario with continuous data insertion, because Milvus does not index segments with a size less than
  <code>index_file_size</code>, it uses brute-force search as the query method. The amount of calculation can be
  estimated by multiplying the number of target vectors by the total number of segment vectors.
</div>
<ul>
  <li>HNSW / RNSG / Annoy index</li>
</ul>
<p>The index parameters of HNSW, RNSG, and Annoy have a more complex impact on query performance. For more information,
  see <a href="index.md">Index Introduction</a>.</p>
<h4>Other</h4>
<ul>
  <li>Result set</li>
</ul>
<p>The size of the result set depends on the number of target vectors and <code>topk</code>. The size of
  <code>topk</code> has little effect on the calculation. However, when the number of target vectors and
  <code>topk</code> are large, the time spent on serializing the result set and network transmission will increase
  accordingly.
</p>
<ul>
  <li>MySQL</li>
</ul>
<p>Milvus uses MySQL as a Metadata backend service. When querying data, Milvus accesses MySQL multiple times to obtain
  Metadata information. Therefore, the response speed of the MySQL service greatly influences the query performance of
  Milvus.</p>
<ul>
  <li>Preload</li>
</ul>
<p>When querying data for the first time, the system needs to read the data from the disk and write the data to the
  cache. This is time-consuming. To avoid loading data during the first query, you can call the
  <code>load_collection</code> API in advance, or use the system parameter <code>preload_collection</code> to specify
  the segment to preload when starting Milvus.
</p>
<ul>
  <li>Compact segments</li>
</ul>
<p>To filter deleted entities, Milvus reads <strong>delete_docs</strong> into memory when querying data. You call
  <code>compact</code> to clean up deleted entities and reduce filtering operations, thereby improving query
  performance.
</p>
<h4>Optimize storage</h4>
<ul>
  <li>Compact segments</li>
</ul>
<p>Deleted entities do not participate in the calculation and takes up disk space. If a large number of entities have
  been deleted, you can call <code>compact</code> to free up disk space.</p>
<h4>FAQ</h4>
<details>
  <summary>
    <font color="#4fc4f9">Why is my GPU always idle?</font>
  </summary>
  <p>It is very likely that Milvus is using CPU for query. If you want to use GPU for query, you need to set the value
    of <code>gpu_search_threshold</code> in <strong>server_config.yaml</strong> to be less than <code>nq</code> (number
    of vectors per query).
  </p>
  <p>
    You can use <code>gpu_search_threshold</code> to set the threshold: when <code>nq</code> is less than this value,
    Milvus uses CPU for queries; otherwise, Milvus uses GPU instead.
  </p>
  <p>
    We do not recommend enabling GPU when the query number is small.
  </p>
</details>
<details>
  <summary>
    <font color="#4fc4f9">Why the search is very slow?</font>
  </summary>
  Check if the value of <code>cache.cache_size</code> in <strong>server_config.yaml</strong> is greater than the size of
  the collection.
</details>
<details>
  <summary>
    <font color="#4fc4f9">How can I get the best performance from Milvus through setting <code>index_file_size</code>?
    </font>
  </summary>
  <p>You need to set <code>index_file_size</code> when creating a collection from a client. This parameter specifies the
    size of each segment, and its default value is 1024 in MB. When the size of newly inserted vectors reaches the
    specified volume, Milvus packs these vectors into a new segment. In other words, newly inserted vectors do not go
    into a segment until they grow to the specified volume. When it comes to creating indexes, Milvus creates one index
    file for each segment. When conducting a vector search, Milvus searches all index files one by one.
  </p>
  <p>
    As a rule of thumb, we would see a 30% ~ 50% increase in the search performance after changing the value of
    <code>index_file_size</code> from 1024 to 2048. Note that an overly large <code>index_file_size</code> value may
    cause failure to load a segment into the memory or graphics memory. Suppose the graphics memory is 2 GB and
    <code>index_file_size</code> 3 GB, each segment is obviously too large.
  </p>
  <p>
    In situations where vectors are not frequently inserted, we recommend setting the value of
    <code>index_file_size</code> to 1024 MB or 2048 MB. Otherwise, we recommend setting the value to 256 MB or 512 MB to
    keep unindexed files from getting too large.
  </p>
  See <a href="tuning.md#Index">Performance Tuning > Index</a> for more information.
</details>
<details>
  <summary>
    <font color="#4fc4f9">Why GPU-enabled query is sometimes slower than CPU-only query?</font>
  </summary>
  <p>Generally speaking, CPU-only query works for situations where <code>nq</code> (number of vectors per query) is
    small, whilst GPU-enabled query works best with a large <code>nq</code>, say 500.
  </p>
  <p>
    Milvus needs to load data from the memory to the graphics memory for a GPU-enabled query. Only when the load time is
    negligible compared to the time to query, is GPU-enabled query faster.
  </p>
</details>
<details>
  <summary>
    <font color="#4fc4f9">Why sometimes the query time for a small dataset is longer?</font>
  </summary>
  If the size of the dataset is smaller than the value of <code>index_file_size</code> that you set when creating a
  collection, Milvus does not create an index for this dataset. Therefore, the time to query in a small dataset may be
  longer. You may as well call <code>create_index</code> to build the index.
</details>
<h2>Mishards: Cluster Sharding Middleware</h2>
<h4>What is Mishards</h4>
<p>Mishards is a Milvus cluster sharding middleware developed in Python. It handles request forwarding, read-write
  separation, horizontal and dynamic scaling, providing you with additional capabilities in terms of expanded memory and
  computing power.</p>
<h4>How Mishards works</h4>
<p>Mishards cascades a request from upstream down to its sub-modules splitting the upstream request, and then collects
  and returns the results of the sub-services to upstream.</p>
<p><img src="../../../assets/mishards.png" alt="proxy"></p>
<h4>Target scenarios</h4>
<table>
  <thead>
    <tr>
      <th>Scenarios</th>
      <th>Concurrency</th>
      <th>Latency</th>
      <th>Data scale</th>
      <th>Suitable for Mishards</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Low</td>
      <td>Low</td>
      <td>Medium / Small</td>
      <td>No</td>
    </tr>
    <tr>
      <td>2</td>
      <td>High</td>
      <td>Low</td>
      <td>Medium / Small</td>
      <td>No</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Low</td>
      <td>High</td>
      <td>Large</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Low</td>
      <td>Low</td>
      <td>Large</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>5</td>
      <td>High</td>
      <td>Low</td>
      <td>Large</td>
      <td>Yes</td>
    </tr>
  </tbody>
</table>
<p>Mishards is suitable for scenarios with large data scale. So how to judge the size of the data scale? There is no
  standard answer to this question because it depends on the hardware resources used in the actual production
  environment. Here is a simple way to determine the size of the data scale:</p>
<ol>
  <li>
    <p>If you do not care about latency, you can assume that a scenario has a large data scale when its data size is
      larger than the available capacity of the hard disk on a single server. For example, the calculation time of the
      server to batch process 5000 query requests is greater than the time to load data from the hard disk to the
      memory, so the available hard disk is the criteria for determining the data scale.</p>
  </li>
  <li>
    <p>Otherwise, you can assume that a scenario has a large data scale when its data size is larger than the available
      memory on a single server.</p>
  </li>
</ol>
<h4>Mishards-based cluster solution</h4>
<h4>Overall architecture</h4>
<p><img src="../../../assets/mishards_structure.png" alt="structure"></p>
<h4>Main components</h4>
<ul>
  <li>Service discovery: Obtains the service addresses of the read and write nodes.</li>
  <li>Load balancer</li>
  <li><strong>Mishards node: A stateless and scalable node.</strong></li>
  <li>Milvus write node: An unscalable node. To avoid failure at a single node, you need to deploy a high availability
    strategy.</li>
  <li>Milvus read node: A stateful and scalable node.</li>
  <li>Shared storage service: Milvus read and write nodes share data through the shared storage service. Available
    options include NAS and NFS.</li>
  <li>Metadata service: Milvus supports only MySQL in the production environment.</li>
</ul>
<h4>Mishards configurations</h4>
<h4>Global configurations</h4>
<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Required</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Debug</code></td>
      <td>No</td>
      <td>Boolean</td>
      <td><code>True</code></td>
      <td>Whether to enable the debug mode. Debug mode only affects the log level for now.<ul>
          <li><code>True</code>: Enable debug mode.</li>
          <li><code>False</code>: Disable debug mode.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code>TIMEZONE</code></td>
      <td>No</td>
      <td>String</td>
      <td><code>UTC</code></td>
      <td>The time zone.</td>
    </tr>
    <tr>
      <td><code>SERVER_PORT</code></td>
      <td>No</td>
      <td>Integer</td>
      <td><code>19530</code></td>
      <td>Defines the service port of Mishards.</td>
    </tr>
    <tr>
      <td><code>WOSERVER</code></td>
      <td>Yes</td>
      <td>String</td>
      <td><code> </code></td>
      <td>The address of Milvus write node. Format: <code>tcp://127.0.0.1:19530</code></td>
    </tr>
  </tbody>
</table>
<h4>Metadata</h4>
<p>Metadata records the structure information of the underlying data. In a distributed system, Milvus write nodes are
  the only producers of metadata; Mishards nodes, Milvus write nodes, and Milvus read nodes are consumers of Metadata.
</p>
<div class="alert note">
  Milvus only supports MySQL or SQLite as its Metadata backend for now. In a distributed system, the storage backend for
  metadata can only be MySQL.
</div>
<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Required</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>SQLALCHEMY_DATABASE_URI</code></td>
      <td>Yes</td>
      <td>String</td>
      <td><code> </code></td>
      <td>Defines the address of the metadata storage database. The format conforms to the RFC-738-style, for example,
        <code>mysql+pymysql://root:root@127.0.0.1:3306/milvus?charset=utf8mb4</code>.
      </td>
    </tr>
    <tr>
      <td><code>SQL_ECHO</code></td>
      <td>No</td>
      <td>Boolean</td>
      <td><code>False</code></td>
      <td>Whether to print detailed SQL queries.<ul>
          <li><code>True</code>: Prints detailed SQL queries.</li>
          <li><code>False</code>: Does not print detailed SQL queries.</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<h4>Service discovery</h4>
<p>Service discovery provides Mishards with the address information of all Milvus read and write nodes. Mishards defines
  the relevant service discovery API <code>IServiceRegistryProvider</code>, and provides extensions in extension mode.
  Milvus provides two extensions by default: <strong>KubernetesProvider</strong> corresponds to Kubernetes cluster;
  <strong>StaticProvider</strong> corresponds to static configuration. You can customize your own service discovery
  extension based on these two extensions.
</p>
<p><img src="../../../assets/mishards_discovery.png" alt="discovery"></p>
<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Required</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DISCOVERY_STATIC_HOSTS</code></td>
      <td>No</td>
      <td>List</td>
      <td><code>[]</code></td>
      <td>When <code>DISCOVERY_CLASS_NAME</code> is <code>static</code>, defines the service address list. The addresses
        in the list are separated by comma, for example, <code>192.168.1.188,192.168.1.190</code>.</td>
    </tr>
    <tr>
      <td><code>DISCOVERY_STATIC_PORT</code></td>
      <td>No</td>
      <td>Integer</td>
      <td><code>19530</code></td>
      <td>When <code>DISCOVERY_CLASS_NAME</code> is <code>static</code>, defines the service address listening port.
      </td>
    </tr>
    <tr>
      <td><code>DISCOVERY_PLUGIN_PATH</code></td>
      <td>No</td>
      <td>String</td>
      <td><code> </code></td>
      <td>The search path to the customized service discovery extension (uses the system search path by default).</td>
    </tr>
    <tr>
      <td><code>DISCOVERY_CLASS_NAME</code></td>
      <td>No</td>
      <td>String</td>
      <td><code>static</code></td>
      <td>In the extension search path, searches for the class based on its name and instantiates it. At present, the
        system provides two classes: <code>static</code> (default) and <code>kubernetes</code>.</td>
    </tr>
    <tr>
      <td><code>DISCOVERY_KUBERNETES_NAMESPACE</code></td>
      <td>No</td>
      <td>String</td>
      <td><code> </code></td>
      <td>When <code>DISCOVERY_CLASS_NAME</code> is <code>kubernetes</code>, defines the namespace of the Milvus
        cluster.</td>
    </tr>
    <tr>
      <td><code>DISCOVERY_KUBERNETES_IN_CLUSTER</code></td>
      <td>No</td>
      <td>Boolean</td>
      <td><code>False</code></td>
      <td>When <code>DISCOVERY_CLASS_NAME</code> is <code>kubernetes</code>, decides whether to run service discovery in
        the cluster.</td>
    </tr>
    <tr>
      <td><code>DISCOVERY_KUBERNETES_POLL_INTERVAL</code></td>
      <td>No</td>
      <td>Integer</td>
      <td><code>5</code></td>
      <td>When <code>DISCOVERY_CLASS_NAME</code> is <code>kubernetes</code>, defines the monitoring period of the
        service discovery (unit: seconds).</td>
    </tr>
    <tr>
      <td><code>DISCOVERY_KUBERNETES_POD_PATT</code></td>
      <td>No</td>
      <td>String</td>
      <td><code> </code></td>
      <td>When <code>DISCOVERY_CLASS_NAME</code> is <code>kubernetes</code>, matches the regular expression to the name
        of Milvus Pod.</td>
    </tr>
    <tr>
      <td><code>DISCOVERY_KUBERNETES_LABEL_SELECTOR</code></td>
      <td>No</td>
      <td>String</td>
      <td><code> </code></td>
      <td>When <code>SD_PROVIDER</code> is <code>kubernetes</code>, matches the label of Milvus Pod, for example,
        <code>tier=ro-servers</code>.
      </td>
    </tr>
  </tbody>
</table>
<h4>Chain tracking</h4>
<p>A distributed systems often distributes requests to multiple internal services. To facilitate troubleshooting, we
  need to track the call chains of internal services. The higher the complexity of the system, the more obvious the
  benefits of a viable chain tracking system. We choose <a href="https://opentracing.io/docs/">OpenTracing</a>, which is
  a distributed tracing standard that has entered CNCF. It provides APIs independent of the platform or vendor to
  facilitate implementation of a chain tracking system.</p>
<p>Mishards defines the chain tracking APIs and provides extensions in extension mode. It provides Jaeger-based
  extensions for now.</p>
<div class="alert note">
  See <a href="https://www.jaegertracing.io/docs/1.18/getting-started/">Jaeger Doc</a> to learn how to integrate Jaeger.
</div>
<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Required</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>TRACER_PLUGIN_PATH</code></td>
      <td>No</td>
      <td>String</td>
      <td><code> </code></td>
      <td>The search path to the custom chain tracking extension (uses the system search path by default).</td>
    </tr>
    <tr>
      <td><code>TRACER_CLASS_NAME</code></td>
      <td>No</td>
      <td>String</td>
      <td><code> </code></td>
      <td>In the extension search path, searches for the class based on its name and instantiates it. Currently, only
        <code>Jaeger</code> is supported, but it is <strong>not used by default</strong>.
      </td>
    </tr>
    <tr>
      <td><code>TRACING_SERVICE_NAME</code></td>
      <td>No</td>
      <td>String</td>
      <td><code>mishards</code></td>
      <td>When <code>TRACING_CLASS_NAME</code> is <a
          href="https://www.jaegertracing.io/docs/1.14/"><code>Jaeger</code></a>, specifies the chain tracking service.
      </td>
    </tr>
    <tr>
      <td><code>TRACING_SAMPLER_TYPE</code></td>
      <td>No</td>
      <td>String</td>
      <td><code>const</code></td>
      <td>When <code>TRACING_CLASS_NAME</code> is <code>Jaeger</code>, specifies the <a
          href="https://www.jaegertracing.io/docs/1.14/sampling/">sampling type</a> for chain tracking.</td>
    </tr>
    <tr>
      <td><code>TRACING_SAMPLER_PARAM</code></td>
      <td>No</td>
      <td>Integer</td>
      <td><code>1</code></td>
      <td>When <code>TRACING_CLASS_NAME</code> is <code>Jaeger</code>, specifies the <a
          href="https://www.jaegertracing.io/docs/1.14/sampling/">sampling frequency</a> for chain tracking.</td>
    </tr>
    <tr>
      <td><code>TRACING_LOG_PAYLOAD</code></td>
      <td>No</td>
      <td>Boolean</td>
      <td><code>False</code></td>
      <td>When <code>TRACING_CLASS_NAME</code> is <code>Jaeger</code>, decides whether to capture the payload for the
        chain tracking.</td>
    </tr>
  </tbody>
</table>
<h4>Log</h4>
<p>The log files of the cluster service are distributed on different nodes, so you need to log in to the relevant server
  to obtain log files for troubleshooting. It is recommended that you use <a
    href="https://www.elastic.co/what-is/elk-stack">ELK</a> log analysis component to collaboratively analyze multiple
  log files and troubleshoot problems.</p>
<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Required</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>LOG_LEVEL</code></td>
      <td>No</td>
      <td>String</td>
      <td><code>DEBUG</code></td>
      <td>Log levels: <code>DEBUG</code> &lt; <code>INFO</code> &lt; <code>WARNING</code> &lt; <code>ERROR</code>.</td>
    </tr>
    <tr>
      <td><code>LOG_PATH</code></td>
      <td>No</td>
      <td>String</td>
      <td><code>/tmp/mishards</code></td>
      <td>Path to log files.</td>
    </tr>
    <tr>
      <td><code>LOG_NAME</code></td>
      <td>No</td>
      <td>String</td>
      <td><code>logfile</code></td>
      <td>Name of log files.</td>
    </tr>
  </tbody>
</table>
<h4>Route</h4>
<p>Mishards obtains the addresses of Milvus read and write nodes from the service discovery center and obtains the
  underlying Metadata information through the Metadata service. Its routing strategy is to consume these materials. As
  shown in the figure, there are 10 data segments (s1, s2, s3, …, s10). We select a consistent hash routing strategy
  based on the name of data segments (<code>FileNameHashRingBased</code>). Mishards routes requests about s1, s4, s6,
  and s9 to the <strong>Milvus 1</strong> node, routes requests about s2, s3, and s5 to the <strong>Milvus 2</strong>
  node, and routes requests about s7, s8, and s10 to the <strong>Milvus 3</strong> node.</p>
<p>Mishards defines APIs related to routing strategies and provides relevant extensions. You can customize your routes
  according to your business scenario and based on the default consistent hash routing extension.</p>
<p><img src="../../../assets/mishards_router.png" alt="router"></p>
<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Required</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ROUTER_CLASS_NAME</code></td>
      <td>No</td>
      <td>String</td>
      <td><code>FileBasedHashRingRouter</code></td>
      <td>In the extension search path, searches for the routed class based on the class name and instantiates it.
        Currently, the system only provides a consistent hash routing strategy <code>FileBasedHashRingRouter</code>
        based on the data segment name.</td>
    </tr>
    <tr>
      <td><code>ROUTER_PLUGIN_PATH</code></td>
      <td>No</td>
      <td>String</td>
      <td><code> </code></td>
      <td>The search path to the custom routing extensions (uses the system search path by default).</td>
    </tr>
  </tbody>
</table>
<h4>Mishards examples</h4>
<h4>Start Mishards</h4>
<h5>Prerequisites</h5>
<ul>
  <li>Milvus properly installed</li>
  <li>Python 3.6 or higher</li>
</ul>
<h5>Start a Milvus and Mishards instance</h5>
<p>Follow these steps to start a Milvus instance and Mishards service on a machine:</p>
<ol>
  <li>
    <p>Clone the Milvus repository to your local machine:</p>
    <pre><code class="language-shell">$ git clone https://github.com/milvus-io/milvus -b 1.1
</code></pre>
  </li>
  <li>
    <p>Install dependencies for Mishards:</p>
    <pre><code class="language-shell">$ cd milvus/shards
$ pip install -r requirements.txt
</code></pre>
  </li>
  <li>
    <p>Start the Milvus service:</p>
    <ul>
      <li>If your Docker version is earlier than v19.03:</li>
    </ul>
    <pre><code class="language-shell">$ sudo docker  run --runtime=nvidia --rm -d -p 19530:19530 -v /tmp/milvus/db:/var/lib/milvus/db milvusdb/milvus:1.1.0-gpu-d050721-5e559c
</code></pre>
    <ul>
      <li>Otherwise:</li>
    </ul>
    <pre><code class="language-shell">$ sudo docker run --gpus all --rm -d -p 19530:19530 -v /tmp/milvus/db:/var/lib/milvus/db milvusdb/milvus:1.1.0-gpu-d050721-5e559c
</code></pre>
  </li>
  <li>
    <p>Change the directory permission:</p>
    <pre><code class="language-shell">$ sudo chown -R $USER:$USER /tmp/milvus
</code></pre>
  </li>
  <li>
    <p>Configure the environment variable for Mishards:</p>
    <pre><code class="language-shell">$ cp mishards/.env.example mishards/.env
</code></pre>
  </li>
  <li>
    <p>Start the Mishards service:</p>
    <pre><code class="language-shell">$ python mishards/main.py
</code></pre>
  </li>
</ol>
<h4>Start Mishards with docker-compose</h4>
<p><code>all_in_one</code> uses a Docker container to start 2 Milvus instances, 1 Mishards middleware instance, and 1
  Jaeger chain tracking instance.</p>
<ol>
  <li>
    <p>Install <a href="https://docs.docker.com/compose/install/">Docker Compose</a>.</p>
  </li>
  <li>
    <p>Clone the Milvus repository to the local machine:</p>
    <pre><code class="language-shell">$ git clone https://github.com/milvus-io/milvus -b 1.1
$ cd milvus/shards
</code></pre>
  </li>
  <li>
    <p>Start all services:</p>
    <pre><code class="language-shell">$ make deploy
</code></pre>
  </li>
  <li>
    <p>Check the service status:</p>
    <pre><code class="language-shell">$ make probe_deploy
Pass ==&gt; Pass: Connected
Fail ==&gt; Error: Fail connecting to server on 127.0.0.1:19530. Timeout
</code></pre>
  </li>
</ol>
<p>To view the service chain, open <a href="http://127.0.0.1:16686/">Jaeger Page</a> in your browser.</p>
<p><img src="../../../assets/jaegerui.png" alt="jaegerui"></p>
<p><img src="../../../assets/jaegertraces.png" alt="jaegertraces"></p>
<p>To clean up all services:</p>
<pre><code class="language-shell">$ make clean_deploy
</code></pre>
<h4>Deploy Mishards cluster in Kubernetes</h4>
<h4>Prerequisites</h4>
<ul>
  <li>Kubernetes 1.10 or later</li>
  <li>Helm 2.12.0 or later</li>
</ul>
<div class="alert note">
  See <a href="https://helm.sh/docs/">Helm Docs</a> for more information about using Helm.
</div>
<h4>Install Mishards</h4>
<ol>
  <li>
    <p>Add the Helm Chart repository:</p>
    <pre><code class="language-bash">$ helm repo add stable https://kubernetes-charts.storage.googleapis.com
</code></pre>
  </li>
  <li>
    <p>Install dependent libraries for Chart:</p>
    <pre><code class="language-bash">$ git clone https://github.com/milvus-io/milvus-helm.git
$ cd milvus-helm/charts/milvus
$ helm dep update
</code></pre>
  </li>
  <li>
    <p>Deploy Mishards:</p>
    <pre><code class="language-bash">$ helm install --set cluster.enabled=true --set persistence.enabled=true milvus-release  .
</code></pre>
  </li>
  <li>
    <p>Check the deployment status:</p>
    <pre><code class="language-bash">$ helm list -f &quot;milvus-release&quot;
</code></pre>
  </li>
</ol>
<h4>Uninstall Mishards</h4>
<ul>
  <li>
    <p>Use Helm v2.x to uninstall Mishards:</p>
    <pre><code class="language-bash">$ helm delete milvus-release
</code></pre>
  </li>
  <li>
    <p>Use Helm v3.x to uninstall Mishards:</p>
    <pre><code class="language-bash">$ helm uninstall milvus-release
</code></pre>
  </li>
</ul>
<h4>Upgrade from standalone service to Mishards cluster</h4>
<p><a href="https://github.com/milvus-io/milvus-helm">Milvus-Helm</a> supports upgrading from standalone service to
  Mishards cluster.</p>
<ol>
  <li>
    <p>Deploy a standalone version of Milvus:</p>
    <pre><code class="language-bash">$ helm install --set persistence.enabled=true milvus-release .
</code></pre>
  </li>
  <li>
    <p>Upgrade to Mishards cluster:</p>
    <pre><code class="language-bash">$ helm upgrade --set cluster.enabled=true --set persistence.enabled=true milvus-release .
</code></pre>
  </li>
</ol>
<h4>Notes</h4>
<p>Mishards is based on shared storage, so the Kubernetes cluster must have available Persistent Volumes (PV). Also,
  ensure that the PV can be used by multiple pods at the same time. You can enable Persistent Volumes by setting
  <code>persistence.enabled</code>.
</p>
<ol>
  <li>In order to share data, the PV access mode must be set to <code>ReadOnlyMany</code> or <code>ReadWriteMany</code>.
  </li>
  <li>Choose a file storage system:
    <ul>
      <li>If your cluster is deployed on AWS, use <a href="https://aws.amazon.com/efs/">Elastic File System (EFS)</a>.
      </li>
      <li>If your cluster is deployed on Azure, use <a
          href="https://docs.microsoft.com/en-us/azure/aks/azure-files-dynamic-pv">Azure File Storage (AFS)</a>.</li>
    </ul>
  </li>
</ol>
<div class="alert note">
  <ul>
    <li>See <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">Persistent Volumes</a> for more
      information about applying for and managing Persistent Volume.</li>
    <li>See <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes">Access Modes</a> for
      more information about the access modes of Persistent Volume.</li>
  </ul>
</div>
<h4>Usage</h4>
<p>You can find all parameters supported by Milvus-Helm at <a href="https://github.com/milvus-io/milvus-helm">Milvus
    Helm Charts</a>.</p>
<ol>
  <li>
    <p>Configure a cluster with multiple read nodes and multiple Mishards sharding middleware.</p>
    <p>Usually, we configure multiple nodes to ensure service availability and increase throughput rate. In the
      following example, the Mishards cluster includes 2 sharding middleware, 2 read nodes, and 1 write node.</p>
    <pre><code class="language-bash">$ helm install
   --set cluster.enabled=true     \
   --set persistence.enabled=true \
   --set mishards.replicas=2       \
   --set readonly.replicas=2       \
   milvus-release .
</code></pre>
    <p>Here, the number of replica sets is controlled by <code>mishards.replicas</code> and
      <code>readonly.replicas</code>. Their default values are 1.
    </p>
    <div class="alert note">
      Currently, the write nodes in the Mishards cluster cannot be expanded.
    </div>
  </li>
  <li>
    <p>Use an externally configured MySQL cluster as the Metadata database.</p>
    <p>Sometimes the support for external MySQL is needed to cooperate with local deployment. Although Milvus-Helm’s
      internal MySQL service does not guarantee high availability, you can increase availability through an external
      MySQL cluster. The following example shows the deployment based on external MySQL.</p>
    <pre><code class="language-bash">$ helm install
   --set cluster.enabled=true             \
   --set persistence.enabled=true         \
   --set mysql.enabled=false              \
   --set externalMysql.enabled=true       \
   --set externalMysql.ip=192.168.1.xx    \
   --set externalMysql.port=3306          \
   --set externalMysql.user=root          \
   --set externalMysql.password=root      \
   --set externalMysql.database=milvus    \
   milvus-release .
</code></pre>
    <p>When using external MySQL, you do not need the built-in MySQL service of Helm. Therefore, you can disable the
      built-in MySQL service of Helm by setting <code>mysql.enabled=false</code>.</p>
  </li>
  <li>
    <p>The read and write nodes of Milvus have different configurations.</p>
    <p>To reasonably use resources, we hope that the read nodes and the write nodes have different configurations. In
      the following example, we configure a read node with 16 GB memory and a write node with 8 GB memory.</p>
    <pre><code class="language-bash">$ helm install
   --set cluster.enabled=true                     \
   --set persistence.enabled=true                 \
   --set cache.cpuCacheCapacity=8                 \
   --set readonly.cache.cpuCacheCapacity=16       \
   milvus-release .
</code></pre>
    <div class="alert note">
      <ul>
        <li>See <a href="milvus_config.md">Milvus configuration</a> for more Milvus configuration parameters.</li>
        <li>See <a href="https://github.com/milvus-io/milvus-helm/blob/master/README.md">Milvus Helm Charts</a> for more
          Milvus-Helm configuration parameters.</li>
      </ul>
    </div>
  </li>
  <li>
    <p>Configure the GPU resources.</p>
    <p>The use of GPU can effectively improve Milvus performance. In the following example, we allow write nodes to use
      GPU resources by setting <code>gpu.enabled=true</code> and prevent the read nodes from using GPU resources by
      setting <code>readonly.gpu.enabled=false</code>.</p>
    <pre><code class="language-bash">$ helm install
   --set cluster.enabled=true             \
   --set persistence.enabled=true         \
   --set gpu.enabled=true                 \
   --set readonly.gpu.enabled=false       \
   milvus-release .
</code></pre>
    <div class="alert note">
      See <a href="https://kubernetes.io/docs/tasks/manage-gpus/scheduling-gpus/">Schedule GPUs</a> for GPU resource
      management and scheduling in Kubernetes.
    </div>
  </li>
</ol>
<h1>FAQ</h1>
<h2>Performance FAQ</h2>
<!-- TOC -->
<!-- /TOC -->
<h5>Why does the first search take a long time after Milvus restarts?</h5>
<p>This is because, after restarting, Milvus needs to load data from the disk to the memory for the first vector search.
  You can set <code>preload_collection</code> in <strong>server_config.yaml</strong> and load as many collections as the
  memory permits. Milvus loads collections to the memory each time it restarts.</p>
<p>Otherwise, you can call <code>load_collection()</code> to load collections to the memory.</p>
<h5>Why the search is very slow?</h5>
<p>Check if the value of <code>cache.cache_size</code> in <strong>server_config.yaml</strong> is greater than the size
  of the collection.</p>
<h5>How do I improve Milvus’ performance?</h5>
<ul>
  <li>Ensure that the value of <code>cache.cache_size</code> in <strong>server_config.yaml</strong> is greater than the
    size of the collection.</li>
  <li>Ensure that all segments are indexed.</li>
  <li>Check if there are other processes on the server consuming CPU resources.</li>
  <li>Adjust the values of <code>index_file_size</code> and <code>nlist</code>.</li>
  <li>If the search performance is unstable, you can add <code>-e OMP_NUM_THREADS=NUM</code> when starting up Milvus,
    where <code>NUM</code> is 2/3 of the number of CPU cores.</li>
</ul>
<p>See <a href="tuning.md">Performance tuning</a> for more information.</p>
<h5>How to set <code>nlist</code> and <code>nprobe</code> for IVF indexes?</h5>
<p>In general terms, the recommended value of <code>nlist</code> is <code>4 × sqrt(n)</code>, where n is the total
  number of entities in a segment.</p>
<p>Determining <code>nprobe</code> is a trade-off between search performance and accuracy, and based on your dataset and
  scenario. It is recommended to run several rounds of tests to determine the value of <code>nprobe</code>.</p>
<p>The following charts are from a test running on the sift50m dataset and IVF_SQ8 index. The test compares search
  performance and recall rate between different <code>nlist</code>/<code>nprobe</code> pairs.</p>
<div class="alert note">
  <p>We only show the results of GPU-enabled Milvus here, because the two distributions of Milvus show similar results.
  </p>
</div>
<img src="../../../assets/accuracy_nlist_nprobe.png" alt="accuracy_nlist_nprobe.png">
<p>Key takeaways: This test shows that the recall rate increases with the <code>nlist</code>/<code>nprobe</code> pair.
</p>
<img src="../../../assets/performance_nlist_nprobe.png" alt="performance_nlist_nprobe.png">
<p>Key takeaways: When <code>nlist</code> is 4096 and <code>nprobe</code> 128, Milvus shows the best search performance.
</p>
<h5>Why sometimes the query time for a small dataset is longer?</h5>
<p>If the size of the dataset is smaller than the value of <code>index_file_size</code> that you set when creating a
  collection, Milvus does not create an index for this dataset. Therefore, the time to query in a small dataset may be
  longer. You may as well call <code>create_index</code> to build the index.</p>
<h5>Why is my GPU always idle?</h5>
<p>It is very likely that Milvus is using CPU for query. If you want to use GPU for query, you need to set the value of
  <code>gpu_search_threshold</code> in <strong>server_config.yaml</strong> to be less than <code>nq</code> (number of
  vectors per query).
</p>
<p>
  You can use <code>gpu_search_threshold</code> to set the threshold: when <code>nq</code> is less than this value,
  Milvus uses CPU for queries; otherwise, Milvus uses GPU instead.
</p>
<p>
  We do not recommend enabling GPU when the query number is small.
</p>
<h5>Why my data cannot be searched immediately after insertion?</h5>
<p>This is because the data has not been flushed from memory to disk. To ensure that data can be searched immediately
  after insertion, you can call <code>flush</code>. However, calling this method too often creates too many small files
  and affects search speed.</p>
<h5>Why does my CPU usage stay low?</h5>
<p>Milvus processes queries in parallel. An <code>nq</code> less than 100 and data on a smaller scale do not require
  high level of parallelism, hence the CPU usage stays low.</p>
<h5>How can I get the best performance from Milvus through setting <code>index_file_size</code>?</h5>
<p>You need to set <code>index_file_size</code> when creating a collection from a client. This parameter specifies the
  size of each segment, and its default value is <code>1024</code> in MB. When the size of newly inserted vectors
  reaches the specified volume, Milvus packs these vectors into a new segment. In other words, newly inserted vectors do
  not go into a segment until they grow to the specified volume. When it comes to creating indexes, Milvus creates one
  index file for each segment. When conducting a vector search, Milvus searches all index files one by one.</p>
<p>As a rule of thumb, we would see a 30% ~ 50% increase in the search performance after changing the value of
  <code>index_file_size</code> from 1024 to 2048. Note that an overly large <code>index_file_size</code> value may cause
  failure to load a segment into the memory or graphics memory. Suppose the graphics memory is 2 GB and
  <code>index_file_size</code> 3 GB, each segment is obviously too large.
</p>
<p>In situations where vectors are not frequently inserted, we recommend setting the value of
  <code>index_file_size</code> to 1024 MB or 2048 MB. Otherwise, we recommend setting the value to 256 MB or 512 MB to
  keep unindexed files from getting too large.
</p>
<p>See <a href="tuning.md#Index">Performance Tuning &gt; Index</a> for more information.</p>
<h5>What is the importing performance of Milvus in practical terms?</h5>
<p>When the client and the server are running on the same physical machine, it takes about 0.8 second to import 100,000
  128-dimensional vectors (to an SSD disk). More specifically, the performance depends on the I/O speed of your disk.
</p>
<h5>Does searching while inserting affect the search speed?</h5>
<ul>
  <li>If the newly inserted vectors have not grown to the specified volume to trigger index creation, Milvus needs to
    load these data directly from disk to memory for a vector search.</li>
  <li>As of v0.9.0, if Milvus has started creating indexes for the newly inserted vectors, an incoming vector search
    interrupts the index creation process, causing a delay of about one second.</li>
</ul>
<h5>Will a batch query benefit from multi-threading?</h5>
<p>If your batch query is on a small scale (<code>nq</code> &lt; 64), Milvus combines the query requests, in which case
  multi-threading helps.</p>
<p>Otherwise, the resources are already exhausted, hence multi-threading does not help much.</p>
<h5>Why GPU-enabled query is sometimes slower than CPU-only query?</h5>
<p>Generally speaking, CPU-only query works for situations where <code>nq</code> (number of vectors per query) is small,
  whilst GPU-enabled query works best with a large <code>nq</code>, say 500.</p>
<p>Milvus needs to load data from the memory to the graphics memory for a GPU-enabled query. Only when the load time is
  negligible compared to the time to query, is GPU-enabled query faster.</p>
<h5>Still have questions?</h5>
<p>You can:</p>
<ul>
  <li>Check out <a href="https://github.com/milvus-io/milvus/issues">Milvus</a> on GitHub. You’re welcome to raise
    questions, share ideas, and help others.</li>
  <li>Join our <a
      href="https://join.slack.com/t/milvusio/shared_invite/enQtNzY1OTQ0NDI3NjMzLWNmYmM1NmNjOTQ5MGI5NDhhYmRhMGU5M2NhNzhhMDMzY2MzNDdlYjM5ODQ5MmE3ODFlYzU3YjJkNmVlNDQ2ZTk">Slack
      community</a> to find more help and have fun!</li>
</ul>
<h2>Product FAQ</h2>
<!-- TOC -->
<!-- /TOC -->
<h5>Is Milvus free of charge?</h5>
<p>Milvus is an open-source project, and hence is free-of-charge.</p>
<p>Please adhere to <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a>, when using Milvus for
  reproduction or distribution purposes.</p>
<h5>Does Milvus support non-x86 architecture?</h5>
<p>No, it does not.</p>
<h5>Does Milvus support CRUD operations on vectors?</h5>
<p>Yes. To update a vector, you can delete it and then insert a new one.</p>
<h5>Can Milvus handle datasets of up to a 100-billion scale?</h5>
<p>By deploying Mishards, a cluster sharding middleware for Milvus, you can process datasets of up to a 100-billion
  scale.</p>
<h5>Where does Milvus store imported data?</h5>
<p>Vectors imported into Milvus are stored locally at <strong>milvus/db/tables/</strong>.</p>
<p>Metadata can be stored in either MySQL or SQLite. See <a href="data_manage.md">Manage Metadata with MySQL</a> for
  more information.</p>
<h5>Why can’t I find vectors on SQLite or MySQL?</h5>
<p>Milvus stores vectors and indexes directly in the disk as files, not in SQLite or MySQL. It uses SQLite or MySQL to
  store metadata of the vectors instead.</p>
<h5>Can I use SQL Server or PostgreSQL to store metadata in Milvus?</h5>
<p>No, we only support storing metadata using SQLite or MySQL.</p>
<h5>Does Milvus’ Python SDK have a connection pool?</h5>
<p>Python SDKs corresponding to Milvus v0.9.0 or later have a connection pool. There is no upper limit on the default
  number of connections in a connection pool.</p>
<h5>Does Milvus support inserting while searching?</h5>
<p>Yes.</p>
<h5>Is there a graphical tool for managing Milvus?</h5>
<p>As of Milvus v0.7.0, we have provided <a href="https://zilliz.com/products/em">Milvus Enterprise Manager</a> as a
  graphical tool for managing Milvus.</p>
<h5>Can I export data from Milvus?</h5>
<p>We do not have a dedicated tool as yet. You can call <code>get_entity_by_id</code> to get the intended vectors by ID.
</p>
<h5>Why do the retrieved vectors suffer precision loss after the <code>get_entity_by_id</code> method call?</h5>
<p>Milvus stores and processes each dimension of a vector in single-precision floating-point format (accurate to seven
  decimal places). Therefore, if the original format of each dimension is double-precision floating-point (accurate to
  sixteen decimal places), you will see a precision loss.</p>
<h5>Should I specify entity IDs when importing vectors or have Milvus generate them for me?</h5>
<p>Either way is fine. But please note that entity IDs in the same collection must be either user-generated or
  Milvus-generated. Can’t be both.</p>
<h5>Can I insert vectors with existing IDs?</h5>
<p>Yes, you can. If you insert vectors with an existing ID, you would end up having duplicate IDs.</p>
<h5>Is there a length limit on the self-defined entity IDs?</h5>
<p>Entity IDs must be non-negative 64-bit integers.</p>
<h5>Is there a volume limit on the vectors inserted each time?</h5>
<p>Vectors inserted each time must not exceed 256 MB.</p>
<h5>Why is the <code>top1</code> result of a vector search not the search vector itself, if the metric type is inner
  product?</h5>
<p>This occurs if you have not normalized the vectors when using inner product as the distance metric.</p>
<h5>Does the size of a collection affect vector searches in one of its partitions, especially when it holds up to 100
  million vectors?</h5>
<p>No. If you have specified partitions when conducting a vector search, Milvus searches the specified partitions only.
</p>
<h5>Does Milvus load the whole collection to the memory if I search only certain partitions in that collection?</h5>
<p>No, Milvus only loads the partitions to search.</p>
<h5>Are queries in segments processed in parallel?</h5>
<p>Yes. But the parallelism processing mechanism varies with Milvus versions.</p>
<p>Suppose a collection has multiple segments, then when a query request comes in:</p>
<ul>
  <li>
    <p>CPU-only Milvus processes the segment reading tasks and the segment searching tasks in pipeline.</p>
  </li>
  <li>
    <p>On top of the abovementioned pipeline mechanism, GPU-enabled Milvus distributes the segments among the available
      GPUs.</p>
  </li>
</ul>
<p>See <a href="https://medium.com/unstructured-data-service/how-does-milvus-schedule-query-tasks-2ca38d7bc2f2">How Does
    Milvus Schedule Query Tasks</a> for more information.</p>
<h5>How to choose an index in Milvus?</h5>
<p>It depends on your scenario. See <a
    href="https://medium.com/unstructured-data-service/how-to-choose-an-index-in-milvus-4f3d15259212">How to Choose an
    Index in Milvus</a> for more information.</p>
<h5>Are indexes partition-specific?</h5>
<p>No. A collection can have only one index type at a time.</p>
<h5>Can Milvus create different types of index in the same collection?</h5>
<p>No. Although a collection can hold various types of data, the same collection can use only one index type.</p>
<h5>Does Milvus create new indexes after vectors are inserted?</h5>
<p>Yes. When the inserted vectors grow to a specified volume, Milvus creates a new segment and starts to create an index
  file for it at the same time. The building of the new index file does not affect the existing index files.</p>
<h5>Does IVF_SQ8 differ from IVF_SQ8H in terms of recall rate?</h5>
<p>No, they have the same recall rate for the same dataset.</p>
<h5>What is the difference between FLAT index and IVF_FLAT index?</h5>
<p>IVF_FLAT index divides a vector space into <code>nlist</code> clusters. If you keep the default value of
  <code>nlist</code> as 16384, Milvus compares the distances between the target vector and the centers of all 16384
  clusters to get <code>nprobe</code> nearest clusters. Then Milvus compares the distances between the target vector and
  the vectors in the selected clusters to get the nearest vectors. Unlike IVF_FLAT, FLAT directly compares the distances
  between the target vector and each and every vector.
</p>
<p>Therefore, when the total number of vectors approximately equals <code>nlist</code>, IVF_FLAT and FLAT has little
  difference in the way of calculation required and search performance. But as the number of vectors grows to two times,
  three times, or n times of <code>nlist</code>, IVF_FLAT index begins to show increasingly greater advantages.</p>
<p>See <a href="https://medium.com/unstructured-data-service/how-to-choose-an-index-in-milvus-4f3d15259212">How to
    Choose an Index in Milvus</a> for more information.</p>
<h5>Why do I see a surge in memory usage when conducting a vector search immediately after an index is created?</h5>
<p>This is because:</p>
<ul>
  <li>
    <p>Milvus loads the newly created index file to the memory for the vector search.</p>
  </li>
  <li>
    <p>The original vector files used to create the index are not yet released from the memory, because the size of
      original vector files and the index file has not exceeded the upper limit specified by
      <code>cache.cache_size</code>.
    </p>
  </li>
</ul>
<h5>Can I update <code>index_file_size</code> and <code>metric_type</code> after creating a collection?</h5>
<p>No, you cannot.</p>
<h5>What is the interval at which Milvus flushes data to the disk?</h5>
<p>Milvus automatically flushes data to disk at intervals of one second.</p>
<h5>If I have set <code>preload_collection</code>, does Milvus service start only after all collections are loaded to
  the memory?</h5>
<p>Yes. If you have set <code>preload_collection</code> in <strong>server_config.yaml</strong>, Milvus’ service is not
  available until it loads all specified collections.</p>
<h5>In what way does Milvus flush data?</h5>
<p>Milvus loads inserted data to the memory and automatically flushes data from memory to the disk at fixed intervals.
  You can call <code>flush</code> to <i>manually</i> trigger this operation.</p>
<h5>What is the recommended configuration for Mishards?</h5>
<p>We recommend that you configure write nodes to using GPU-enabled Milvus and read nodes to using CPU-only Milvus. If
  you can have only one write node, you can configure this node to using GPU-enabled Milvus for creating indexes and
  configure read nodes to using CPU-only Milvus.</p>
<h5>Does Mishards support RESTful APIs?</h5>
<p>No, it does not.</p>
<h5>What is normalization? Why is normalization needed?</h5>
<p>Normalization refers to the process of converting an embedding (vector) so that its norm equals 1. If you use Inner
  Product to calculate embeddings similarities, you must normalize your embeddings. After normalization, inner product
  equals cosine similarity.</p>
<p>See <a href="https://en.wikipedia.org/wiki/Unit_vector">Wikipedia</a> for more information.</p>
<h5>Why do I get different results using Euclidean distance (L2) and inner product (IP) as the distance metric?</h5>
<p>Check if the vectors are normalized. If not, you need to normalize the vectors first. Theoretically speaking,
  similarities worked out by L2 are different from similarities worked out by IP, if the vectors are not normalized.</p>
<h5>Is there a limit on the total number of collections and partitions?</h5>
<p>There is no limit on the number of collections. The upper limit on the number of partitions in a collection is 4096.
</p>
<h5>Why do I get fewer than k vectors when searching for <code>topk</code> vectors?</h5>
<p>Among the indexes that Milvus supports, IVF_FLAT and IVF_SQ8 implement the k-means clustering method. A data space is
  divided into <code>nlist</code> clusters and the inserted vectors are distributed to these clusters. Milvus then
  selects the <code>nprobe</code> nearest clusters and compares the distances between the target vector and all vectors
  in the selected clusters to return the final results.</p>
<p>If <code>nlist</code> and <code>k</code> are large and <code>nprobe</code> is small, the amount of vectors in the
  <code>nprobe</code> clusters may be less than <code>k</code>. Therefore, when you search for the <code>topk</code>
  nearest vectors, the number of returned vectors is less than k.
</p>
<p>To avoid this, try setting <code>nprobe</code> larger and <code>nlist</code> and <code>k</code> smaller.</p>
<p>See <a href="index.md">Index Types</a> for more information.</p>
<h5>What is the maximum dimension of a vector in Milvus?</h5>
<p>Milvus can support vectors with up to 32,768 dimensions.</p>
<h5>Why does Milvus set an upper limit of 256 MB for the data that can be inserted at a time?</h5>
<p>Data inserted to Milvus is first written into memory. This limit is to avoid over-occupation of memory resources.</p>
<h5>Milvus merges multi-thread query requests in one batch. How to cancel this mechanism?</h5>
<p>You can add the following section to the configuration file <strong>server_config.yaml</strong>:</p>
<pre><code class="language-yaml">engine_config:
  search_combine_nq: 1
</code></pre>
<h5>Still have questions?</h5>
<p>You can:</p>
<ul>
  <li>Check out <a href="https://github.com/milvus-io/milvus/issues">Milvus</a> on GitHub. You’re welcome to raise
    questions, share ideas, and help others.</li>
  <li>Join our <a
      href="https://join.slack.com/t/milvusio/shared_invite/enQtNzY1OTQ0NDI3NjMzLWNmYmM1NmNjOTQ5MGI5NDhhYmRhMGU5M2NhNzhhMDMzY2MzNDdlYjM5ODQ5MmE3ODFlYzU3YjJkNmVlNDQ2ZTk">Slack
      community</a> to find more help and have fun!</li>
</ul>
<h2>Operational FAQ</h2>
<!-- TOC -->
<!-- /TOC -->
<h5>What if I failed to pull Milvus Docker image from Docker Hub?</h5>
<p>Users in some countries may have limited access to Docker Hub. In this case, you can pull the Docker image from other
  registry mirrors. You can add the URL <code>&quot;https://registry.docker-cn.com&quot;</code> to the
  <code>registry-mirrors</code> array in <code>/etc.docker/daemon.json</code>.
</p>
<pre><code class="language-json">{
  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]
}
</code></pre>
<h5>Is Docker the only way to install and run Milvus?</h5>
<p>No. You can also build Milvus from source code in Linux. See <a
    href="https://github.com/milvus-io/milvus/blob/master/INSTALL.md">Build Milvus from source code</a> for more
  information.</p>
<h5>Why does Milvus return <code>config check error</code>?</h5>
<p>The version of configuration file does not match the version your Milvus server.</p>
<h5>Why do I get <code>no space left on device</code> when importing data to Milvus?</h5>
<p>It is likely that you have not saved enough disk space.</p>
<h5>Why is my recall rate unsatisfying?</h5>
<p>You can increase the value of <code>nprobe</code> when searching from a client. The greater the value, the more
  accurate the result, and the more time it takes.</p>
<p>See <a href="tuning.md#Index">Performance Tuning &gt; Index</a> for more information.</p>
<h5>Why does my updated configuration not work?</h5>
<p>You need to restart Milvus Docker each time you update the configuration file. See <a
    href="milvus_config.md#Updating-configurations">Milvus Server Configuration &gt; Updating configurations</a>.</p>
<h5>How can I know if Milvus has started successfully?</h5>
<p>Run <code>sudo docker logs &lt;container ID&gt;</code> to check if Milvus is running properly.</p>
<h5>Why is the time in the log files different from the system time?</h5>
<p>The log files in the Docker container use UTC time by default. If your host machine does not use UTC time, then the
  time in the log files is different. We recommend that you mount the log files onto your host machine to keep the time
  consistent between the log and the host.</p>
<h5>How can I know whether my CPU supports Milvus?</h5>
<p>The instruction sets that Milvus supports are SSE42, AVX, AVX2, and AVX512. Your CPU must support at least one of
  them for Milvus to function properly.</p>
<h5>Why does Milvus return <code>illegal instruction</code> during startup?</h5>
<p>If your CPU does not support SSE42, AVX, AVX2, or AVX512, Milvus cannot start properly. You can use
  <code>cat /proc/cpuinfo</code> to check the supported instruction sets.
</p>
<h5>How can I know whether my GPU is supported by Milvus?</h5>
<p>Milvus supports CUDA architecture 6.0 or later. See <a href="https://en.wikipedia.org/wiki/CUDA">Wikipedia</a> for
  supported architectures.</p>
<h5>Where is the script for starting the server in the Milvus Docker container?</h5>
<p>It is at <strong>/var/lib/milvus/script/</strong> in the Milvus Docker container.</p>
<h5>Besides the configuration file, how can I tell Milvus is using GPU for search?</h5>
<p>Use any of the following methods:</p>
<ul>
  <li>
    <p>Use <code>nvidia-smi</code> to monitor your GPU usage.</p>
  </li>
  <li>
    <p>Use Prometheus to monitor performance metrics. See <a
        href="setup_grafana.md#System-performance-metrics">Visualize Metrics in Grafana &gt; System performance
        metrics</a>.</p>
  </li>
  <li>
    <p>Check the Milvus server logs.</p>
  </li>
</ul>
<h5>Can I install Milvus on Windows?</h5>
<p>Yes, so long as you have set up a Docker environment on your operating system.</p>
<h5>How to fix the error when I install pymilvus on Windows?</h5>
<p>Try installing pymilvus in a Conda environment.</p>
<h5>Can I deploy Milvus service in an air-gapped environment?</h5>
<p>Milvus is released as a Docker image. Follow these steps to deploy it from offline:</p>
<ol>
  <li>
    <p>Pull the latest Milvus Docker image when you have Internet access.</p>
  </li>
  <li>
    <p>Run <code>docker save</code> to save the Docker image as a TAR file.</p>
  </li>
  <li>
    <p>Transfer the TAR file to the air-gapped environment.</p>
  </li>
  <li>
    <p>Run <code>docker load</code> to load the file as a Docker image.</p>
  </li>
</ol>
<p>For more information about Docker, see <a href="https://docs.docker.com/">docs.docker.com</a>.</p>
<h5>How can I differentiate if I have multiple Milvus nodes connected to Pushgateway?</h5>
<p>You can add a Prometheus instance in <strong>prometheus.yaml</strong>. Then Prometheus or Granafa will show the
  monitoring data, as well as the source node.</p>
<h5>Which database system should I use to manage Metadata, SQLite or MySQL?</h5>
<p>We recommend using MySQL to manage Metadata in production environment.</p>
<h5>How to calculate required memory based on the size of the dataset?</h5>
<p>Different indexes require different memory space. You can use <a href="https://zilliz.com/sizing-tool">Milvus sizing
    tool</a> to calculate the required memory for a vector search.</p>
<h5>How to migrate data in Milvus?</h5>
<p>Copy the entire <strong>db</strong> directory of the original Milvus service to the new directory. When restarting
  the Milvus service, map the copied <strong>db</strong> directory to the <strong>db</strong> directory of the Milvus
  service.</p>
<div class="alert note">
  Note: Data formats of different versions may not be compatible with each other. The current data format is backward
  compatible with Milvus v0.7.0.
</div>
<h5>Can I increase my storage by adding interfaces such as S3 or GlusterFS?</h5>
<p>No, you cannot. Milvus does not support this feature for now.</p>
<h5>Why do I see
  <code>WARN: increase temp memory to avoid cudaMalloc, or decrease query/add size (alloc 307200000 B, highwater 0 B)</code>
  in the log file?
</h5>
<p>You receive this warning if the graphics memory required for a request is larger than the graphics memory allocated
  beforehand. The warning merely denotes an insufficient graphics memory. Milvus will expand the graphics memory
  accordingly.</p>
<h5>Why does Milvus return <code>database is locked</code>?</h5>
<p>If you use SQLite to manage Metadata, you receive this error message when write requests occur frequently. We
  recommend using MySQL for Metadata management. See <a href="data_manage.md">Manage Metadata with MySQL</a>.</p>
<h5>Got an error <code>Segmentation Fault</code> from PyMilvus. What shall I do?</h5>
<p>PyMilvus v1.1.0 allows you to download the latest version of the grpcio library. The server of Milvus v1.x is built
  on a earlier, customized version of gRPC, which is incompatible with the latest grpcio library. To fix this issue,
  either upgrade your PyMilvus version from v1.1.0 to v1.1.1 or roll back your grpcio library to 1.37.0:</p>
<pre><code>pip install grpcio==1.37.0
pip install grpcio-tools==1.37.0
</code></pre>
<h5>Can I specify the timeout for <code>Milvus()</code>?</h5>
<p>Yes, PyMilvus v1.1.2 supports specifying the server connection timeout.</p>
<h5>How to assign GPU devices to index/search?</h5>
<p>In <b>server_config.yaml</b> file under /home/$USER/milvus/conf, you can assign GPU devices to index/search. See
  example:</p>
<pre><code>gpu:
  enable: true
  cache_size: 10GB
  gpu_search_threshold: 0
  search_devices:
    - gpu0
    - gpu1
  build_index_devices:
    - gpu2
    - gpu3
</code></pre>
<div class="alert note">
  GPU 0,1,2,3 are first 4 GPUs from the list of GPU devices assigned to the docker container.
</div>
<h5>Still have questions?</h5>
<p>You can:</p>
<ul>
  <li>Check out <a href="https://github.com/milvus-io/milvus/issues">Milvus</a> on GitHub. You’re welcome to raise
    questions, share ideas, and help others.</li>
  <li>Join our <a
      href="https://join.slack.com/t/milvusio/shared_invite/enQtNzY1OTQ0NDI3NjMzLWNmYmM1NmNjOTQ5MGI5NDhhYmRhMGU5M2NhNzhhMDMzY2MzNDdlYjM5ODQ5MmE3ODFlYzU3YjJkNmVlNDQ2ZTk">Slack
      community</a> to find more help and have fun!</li>
</ul>
<h2>Troubleshooting</h2>
<h4>Troubleshoot</h4>
<p>This page describes the common issues you may run into with Milvus. The issues fall into the following categories:
</p>
<h4>Startup issue</h4>
<p>Issues that occur at the startup of Milvus server, and that generally lead to server startup failures. You can check
  the corresponding error messages by below command:</p>
<pre><code class="language-shell">$ docker logs &lt;milvus container id&gt;
</code></pre>
<h4>Operational issue</h4>
<p>Issues that occur during the server operation, which may cause server down. If you encounter issues during operation,
  first confirm that whether the issue is caused by the incompatibility of Milvus and SDK versions. Then check the error
  messages that are recorded in <strong>/home/$USER/milvus/logs</strong>.</p>
<h4>API issue</h4>
<p>Issues that occur during the operation with Milvus through APIs. Corresponding error messages will be returned in
  real time to the client.</p>
<p>If you cannot resolve the issue easily yourself, you can:</p>
<ul>
  <li><a
      href="https://join.slack.com/t/milvusio/shared_invite/enQtNzY1OTQ0NDI3NjMzLWNmYmM1NmNjOTQ5MGI5NDhhYmRhMGU5M2NhNzhhMDMzY2MzNDdlYjM5ODQ5MmE3ODFlYzU3YjJkNmVlNDQ2ZTk">Join
      our Slack channel</a> and reach out for support from Milvus team.</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/new/choose">File an Issue</a> on GitHub and describe the
    problem in detail.</li>
</ul>
<h1>API Reference</h1>
<h1>Tools</h1>
<h2>Overview</h2>
<h4>Milvus Developer Tool Overview</h4>
<p>You can use the following tools to improve your developing experience with Milvus.</p>
<ul>
  <li><a href="https://zilliz.com/products/em">Milvus Enterprise Manager</a>: An intuitive GUI tool for managing and
    interacting with the Milvus server.</li>
  <li><a href="https://zilliz.com/sizing-tool">Milvus Sizing Tool</a>: A utility for estimating your hardware
    configuration based on your application scenario.</li>
  <li><a href="https://www.zilliz.com/blog/Milvus-Data-Migration-Tool">MilvusDM</a>: A data migration tool for importing
    and exporting Milvus data files.</li>
</ul>
<h2>MilvusDM</h2>
<h4>Overview</h4>
<p><a href="https://github.com/milvus-io/milvus-tools">MilvusDM</a> (Milvus Data Migration) is an open-source tool
  designed specifically for importing and exporting data files with Milvus. MilvusDM can greatly improve data mangement
  efficiency and reduce DevOps costs in the following ways:</p>
<ul>
  <li>
    <p><a href="#Faiss-to-Milvus">Faiss to Milvus</a>: Imports unzipped data from Faiss into Milvus.</p>
  </li>
  <li>
    <p><a href="#HDF5-to-Milvus">HDF5 to Milvus</a>: Imports HDF5 files into Milvus.</p>
  </li>
  <li>
    <p><a href="#Milvus-to-Milvus">Milvus to Milvus</a>: Migrates data from a source Milvus to the target Milvus.</p>
  </li>
  <li>
    <p><a href="#Milvus-to-HDF5">Milvus to HDF5</a>: Saves the data in Milvus as HDF5 files.</p>
  </li>
</ul>
<p><img src="https://assets.zilliz.com/milvusdm_blog_2_7824b16e5e.png" alt="milvusdm blog 1.png"></p>
<p>MilvusDM is hosted on Github and can be easily installed by running the command line <code>pip3 install</code>
  pymilvusdm. MilvusDM allows you to migrate data in a specific collection or partition. In the following sections, we
  will explain how to use each data migration type.</p>
<h4>Faiss to Milvus</h4>
<h4>Steps</h4>
<p>1.Download <strong>F2M.yaml</strong>:</p>
<p><code>$ wget https://raw.githubusercontent.com/milvus-io/milvus-tools/main/yamls/F2</code></p>
<p>2.Set the following parameters:</p>
<ul>
  <li>
    <p><code>data_path</code>: Data path (vectors and their corresponding IDs) in Faiss.</p>
  </li>
  <li>
    <p><code>dest_host</code>: Milvus server address.</p>
  </li>
  <li>
    <p><code>dest_port</code>: Milvus server port.</p>
  </li>
  <li>
    <p><code>mode</code>: Data can be imported to Milvus using the following modes:</p>
    <ul>
      <li>
        <p>Skip: Ignore data if the collection or partition already exists.</p>
      </li>
      <li>
        <p>Append: Append data if the collection or partition already exists.</p>
      </li>
      <li>
        <p>Overwrite: Delete data before insertion if the collection or partition already exists.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code>dest_collection_name</code>: Name of receiving collection for data import.</p>
  </li>
  <li>
    <p><code>dest_partition_name</code>: Name of receiving partition for data import.</p>
  </li>
  <li>
    <p><code>collection_parameter</code>: Collection-specific information such as vector dimension, index file size, and
      distance metric.</p>
  </li>
</ul>
<pre><code>F2M:
  milvus_version: 1.1.0
  data_path: '/home/data/faiss.index'
  dest_host: '127.0.0.1'
  dest_port: 19530
  mode: 'append'        #### 'skip/append/overwrite'
  dest_collection_name: 'test'
  dest_partition_name: ''
  collection_parameter:
    dimension: 256
    index_file_size: 1024
    metric_type: 'L2'
</code></pre>
<p>3.Run <strong>F2M.yaml:</strong></p>
<p><code>$ milvusdm --yaml F2M.yaml</code></p>
<h4>Sample Code</h4>
<p>1.Read Faiss files to retrieve vectors and their corresponding IDs.</p>
<p><code>ids, vectors = faiss_data.read_faiss_data()</code></p>
<p>2.Insert the retrieved data into Milvus:</p>
<p>
  <code>insert_milvus.insert_data(vectors, self.dest_collection_name, self.collection_parameter, self.mode, ids, self.dest_partition_name)</code>
</p>
<h4>HDF5 to Milvus</h4>
<h4>Steps</h4>
<p>1.Download <strong>H2M.yaml</strong>.</p>
<p><code>$ wget https://raw.githubusercontent.com/milvus-io/milvus-tools/main/yamls/H2M.yaml</code></p>
<p>2.Set the following parameters:</p>
<ul>
  <li>
    <p><code>data_path</code>: Path to the HDF5 files.</p>
  </li>
  <li>
    <p><code>data_dir</code>: Directory holding the HDF5 files.</p>
  </li>
  <li>
    <p><code>dest_host</code>: Milvus server address.</p>
  </li>
  <li>
    <p><code>dest_port</code>: Milvus server port.</p>
  </li>
  <li>
    <p><code>mode</code>: Data can be imported to Milvus using the following modes:</p>
    <ul>
      <li>
        <p>Skip: Ignore data if the collection or partition already exists.</p>
      </li>
      <li>
        <p>Append: Append data if the collection or partition already exists.</p>
      </li>
      <li>
        <p>Overwrite: Delete data before insertion if the collection or partition already exists.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code>dest_collection_name</code>: Name of receiving collection for data import.</p>
  </li>
  <li>
    <p><code>dest_partition_name</code>: Name of receiving partition for data import.</p>
  </li>
  <li>
    <p><code>collection_parameter</code>: Collection-specific information such as vector dimension, index file size, and
      distance metric.</p>
  </li>
</ul>
<blockquote>
  <p>Set either <code>data_path</code> or <code>data_dir</code>. Do <strong>not</strong> set both. Use
    <code>data_path</code> to specify multiple file paths, or <code>data_dir</code> to specify the directory holding
    your data file.
  </p>
</blockquote>
<pre><code>H2M:
  milvus-version: 1.1.0
  data_path:
    - /Users/zilliz/float_1.h5
    - /Users/zilliz/float_2.h5
  data_dir:
  dest_host: '127.0.0.1'
  dest_port: 19530
  mode: 'overwrite'        #### 'skip/append/overwrite'
  dest_collection_name: 'test_float'
  dest_partition_name: 'partition_1'
  collection_parameter:
    dimension: 128
    index_file_size: 1024
    metric_type: 'L2'
</code></pre>
<p>3.Run <strong>H2M.yaml:</strong></p>
<p><code>$ milvusdm --yaml H2M.yaml</code></p>
<h4>Sample Code</h4>
<p>1.Read the HDF5 files to retrieve vectors and their corresponding IDs:</p>
<p><code>vectors, ids = self.file.read_hdf5_data()</code></p>
<p>2.Insert the retrieved data into Milvus:</p>
<p><code>ids = insert_milvus.insert_data(vectors, self.c_name, self.c_param, self.mode, ids,self.p_name)</code></p>
<h4>Milvus to Milvus</h4>
<h4>Steps</h4>
<p>1.Download <strong>M2M.yaml</strong>.</p>
<p><code>$ wget https://raw.githubusercontent.com/milvus-io/milvus-tools/main/yamls/M2M.yaml</code></p>
<p>2.Set the following parameters:</p>
<ul>
  <li>
    <p><code>source_milvus_path</code>: Source Milvus work path.</p>
  </li>
  <li>
    <p><code>mysql_parameter</code>: Source Milvus MySQL settings. If MySQL is not used, set mysql_parameter as ‘’.</p>
  </li>
  <li>
    <p><code>source_collection</code>: Names of the collection and its partitions in the source Milvus.</p>
  </li>
  <li>
    <p><code>dest_host</code>: Milvus server address.</p>
  </li>
  <li>
    <p><code>dest_port</code>: Milvus server port.</p>
  </li>
  <li>
    <p><code>mode</code>: Data can be imported to Milvus using the following modes:</p>
    <ul>
      <li>
        <p>Skip: Ignore data if the collection or partition already exists.</p>
      </li>
      <li>
        <p>Append: Append data if the collection or partition already exists.</p>
      </li>
      <li>
        <p>Overwrite: Delete data before insertion if the collection or partition already exists.</p>
      </li>
    </ul>
  </li>
</ul>
<pre><code>M2M:
  milvus_version: 1.1.0
  source_milvus_path: '/home/user/milvus'
  mysql_parameter:
    host: '127.0.0.1'
    user: 'root'
    port: 3306
    password: '123456'
    database: 'milvus'
  source_collection:
    test:
      - 'partition_1'
      - 'partition_2'
  dest_host: '127.0.0.1'
  dest_port: 19530
  mode: 'skip' #### 'skip/append/overwrite'
</code></pre>
<p>3.Run <strong>M2M.yaml.</strong></p>
<p><code>$ milvusdm --yaml M2M.yaml</code></p>
<h4>Sample Code</h4>
<p>1.According to a specified collection or partition’s metadata, read the files under <strong>milvus/db</strong> on
  your local drive to retrieve vectors and their corresponding IDs from the source Milvus.</p>
<pre><code>collection_parameter, _ = milvus_meta.get_collection_info(collection_name)
r_vectors, r_ids, r_rows = milvusdb.read_milvus_file(self.milvus_meta, collection_name, partition_tag) 
</code></pre>
<p>2.Insert the retrieved data into the target Milvus.</p>
<p>
  <code>milvus_insert.insert_data(r_vectors, collection_name, collection_parameter, self.mode, r_ids, partition_tag)</code>
</p>
<h4>Milvus to HDF5</h4>
<h4>Steps</h4>
<p>1.Download <strong>M2H.yaml</strong>:</p>
<p><code>$ wget https://raw.githubusercontent.com/milvus-io/milvus-tools/main/yamls/M2H.yaml</code></p>
<p>2.Set the following parameters:</p>
<ul>
  <li>
    <p><code>source_milvus_path</code>: Source Milvus work path.</p>
  </li>
  <li>
    <p><code>mysql_parameter</code>: Source Milvus MySQL settings. If MySQL is not used, set mysql_parameter as ‘’.</p>
  </li>
  <li>
    <p><code>source_collection</code>: Names of the collection and its partitions in the source Milvus.</p>
  </li>
  <li>
    <p><code>data_dir</code>: Directory for holding saved HDF5 files.</p>
  </li>
</ul>
<pre><code>M2H:
  milvus_version: 1.1.0
  source_milvus_path: '/home/user/milvus'
  mysql_parameter:
    host: '127.0.0.1'
    user: 'root'
    port: 3306
    password: '123456'
    database: 'milvus'
  source_collection: #### specify the 'partition_1' and 'partition_2' partitions of the 'test' collection.
    test:
      - 'partition_1'
      - 'partition_2'
  data_dir: '/home/user/data'
</code></pre>
<p>3.Run <strong>M2H.yaml</strong>:</p>
<p><code>$ milvusdm --yaml M2H.yaml</code></p>
<h4>Sample Code</h4>
<p>1.According to a specified collection or partition’s metadata, read the files under <strong>milvus/db</strong> on
  your local drive to retrieve vectors and their corresponding IDs…</p>
<pre><code>collection_parameter, version = milvus_meta.get_collection_info(collection_name)
r_vectors, r_ids, r_rows = milvusdb.read_milvus_file(self.milvus_meta, collection_name, partition_tag)
</code></pre>
<p>2.Save the retrieved data as HDF5 files.</p>
<p><code>data_save.save_yaml(collection_name, partition_tag, collection_parameter, version, save_hdf5_name)</code></p>
<h4>MilvusDM File Structure</h4>
<p>The flow chart below shows how MilvusDM performs different tasks according to the YAML file it receives:</p>
<p><img src="https://assets.zilliz.com/milvusdm_blog_2_7824b16e5e.png" alt="milvusdm blog 2.png"></p>
<p>MilvusDM file structure:</p>
<ul>
  <li>
    <p>pymilvusdm</p>
    <ul>
      <li>
        <p>core</p>
        <ul>
          <li>
            <p><strong>milvus_client.py</strong>: Performs client operations in Milvus.</p>
          </li>
          <li>
            <p><strong>read_data.py</strong>: Reads the HDF5 data files on your local drive. (Add your code here to
              support reading data files in other formats.)</p>
          </li>
          <li>
            <p><strong>read_faiss_data.py</strong>: Reads the data files in Faiss.</p>
          </li>
          <li>
            <p><strong>read_milvus_data.py</strong>: Reads the data files in Milvus.</p>
          </li>
          <li>
            <p><strong>read_milvus_meta.py</strong>: Reads the metadata in Milvus.</p>
          </li>
          <li>
            <p><strong>data_to_milvus.py</strong>: Creates collections or partitions based on parameters in YAML files
              and imports the vectors and the corresponding vector IDs into Milvus.</p>
          </li>
          <li>
            <p><strong>save_data.py</strong>: Saves the data as HDF5 files.</p>
          </li>
          <li>
            <p><strong>write_logs.py</strong>: Writes logs during runtime.</p>
          </li>
        </ul>
      </li>
      <li>
        <p><strong>faiss_to_milvus.py</strong>: Imports data from Faiss into Milvus.</p>
      </li>
      <li>
        <p><strong>hdf5_to_milvus.py</strong>: Imports data in HDF5 files into Milvus.</p>
      </li>
      <li>
        <p><strong>milvus_to_milvus.py</strong>: Migrates data from a source Milvus to the target Milvus.</p>
      </li>
      <li>
        <p><strong>milvus_to_hdf5.p</strong>y: Exports data in Milvus and saves them as HDF5 files.</p>
      </li>
      <li>
        <p><strong><a href="http://main.py">main.py</a></strong>: Performs corresponding tasks according to the received
          YAML file.</p>
      </li>
      <li>
        <p><strong><a href="http://setting.py">setting.py</a></strong>: Configurations relating to running the MilvusDM
          code.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><a href="http://setup.py">setup.py</a></strong>: Creates <strong>pymilvusdm</strong> file packages and
      uploads them to PyPI (Python Package Index).</p>
  </li>
</ul>
<h4>Recap</h4>
<p>MilvusDM primarily handles migrating data in and out of Milvus, which includes Faiss to Milvus, HDF5 to Milvus,
  Milvus to Milvus, and Milvus to HDF5.</p>
<p>The following features are planned for upcoming releases:</p>
<ul>
  <li>
    <p>Import binary data from Faiss to Milvus.</p>
  </li>
  <li>
    <p>Blocklist and allowlist for data migration between source Milvus and target Milvus.</p>
  </li>
  <li>
    <p>Merge and import data from multiple collections or partitions in source Milvus to a new collection in target
      Milvus.</p>
  </li>
  <li>
    <p>Backup and recovery of Milvus data.</p>
  </li>
</ul>
<p>The Milvusdm project is open source and available on <a href="https://github.com/milvus-io/milvus-tools">Github</a>.
  Any and all contributions to the project are welcome. Give it a star 🌟, and feel free to file an <a
    href="https://github.com/milvus-io/milvus-tools/issues">issue</a> or submit your own code!</p>
<h1>Release Notes</h1>
<h4>Release notes</h4>
<h4>v1.1.0</h4>
<p><strong>Release date</strong>：2021-05-07</p>
<h5>Compatibility</h5>
<table>
  <thead>
    <tr>
      <th style="text-align:left">Milvus version</th>
      <th style="text-align:left">Python SDK version</th>
      <th style="text-align:left">Java SDK version</th>
      <th style="text-align:left">Go SDK version</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">1.1.0</td>
      <td style="text-align:left">1.1.0</td>
      <td style="text-align:left">1.1.0</td>
      <td style="text-align:left">1.1.0</td>
    </tr>
  </tbody>
</table>
<h5>New Features</h5>
<ul>
  <li><a href="https://github.com/milvus-io/milvus/issues/4564">#4564</a> Supports specifying partition in a
    <code>get_entity_by_id()</code> method call.
  </li>
  <li><a href="https://github.com/milvus-io/milvus/issues/4806">#4806</a> Supports specifying partition in a
    <code>delete_entity_by_id()</code> method call.
  </li>
  <li><a href="https://github.com/milvus-io/milvus/issues/4905">#4905</a> Adds the <code>release_collection()</code>
    method, which unloads a specific collection from cache.</li>
</ul>
<h5>Improvements</h5>
<ul>
  <li><a href="https://github.com/milvus-io/milvus/issues/4756">#4756</a> Improves the performance of the
    <code>get_entity_by_id()</code> method call.
  </li>
  <li><a href="https://github.com/milvus-io/milvus/issues/4856">#4856</a> Upgrades hnswlib to v0.5.0.</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/4958">#4958</a> Improves the performance of IVF index
    training.</li>
</ul>
<h5>Fixed issues</h5>
<ul>
  <li><a href="https://github.com/milvus-io/milvus/issues/4778">#4778</a> Fails to access vector index in Mishards.</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/4797">#4797</a> The system returns false results after merging
    search requests with different <code>topK</code> parameters.</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/4838">#4838</a> The server does not respond immediately to an
    index building request on an empty collection.</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/4858">#4858</a> For GPU-enabled Milvus, the system crashes on
    a search request with a large <code>topK</code> (&gt; 2048).</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/4862">#4862</a> A read-only node merges segments during
    startup.</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/4894">#4894</a> The capacity of a Bloom filter does not equal
    to the row count of the segment it belongs to.</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/4908">#4908</a> The GPU cache is not cleaned up after a
    collection is dropped.</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/4933">#4933</a> It takes a long while for the system to build
    index for a small segment.</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/4952">#4952</a> Fails to set timezone as “UTC + 5:30”.</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/5008">#5008</a> The system crashes randomly during continuous,
    concurrent delete, insert, and search operations.</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/5010">#5010</a> For GPU-enabled Milvus, query fails on IVF_PQ
    if <code>nbits</code> ≠ 8.</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/5050">#5050</a> <code>get_collection_stats()</code> returns
    false index type for segments still in the process of index building.</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/5063">#5063</a> The system crashes when an empty segment is
    flushed.</li>
  <li><a href="https://github.com/milvus-io/milvus/issues/5078">#5078</a> For GPU-enabled Milvus, the system crashes
    when creating an IVF index on vectors of 2048, 4096, or 8192 dimensions.</li>
</ul>
<h4>v1.0.0</h4>
<p><strong>Release date</strong>：2021-03-09</p>
<h5>Compatibility</h5>
<table>
  <thead>
    <tr>
      <th style="text-align:left">Milvus version</th>
      <th style="text-align:left">Python SDK version</th>
      <th style="text-align:left">Java SDK version</th>
      <th style="text-align:left">Go SDK version</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">1.0.0</td>
      <td style="text-align:left">1.0.x</td>
      <td style="text-align:left">1.0.x</td>
      <td style="text-align:left">1.0.x</td>
    </tr>
  </tbody>
</table>
<h5>New Features</h5>
<ul>
  <li>Supports writing log to stdout. <a href="https://github.com/milvus-io/milvus/issues/3977">#3977</a></li>
</ul>
<h5>Improvements</h5>
<ul>
  <li>Reduces the package size of grpc-milvus for the C++ SDK. <a
      href="https://github.com/milvus-io/milvus/issues/4754">#4754</a></li>
</ul>
<h5>Fixed issues</h5>
<ul>
  <li>Memory leaks during indexing or querying operations. <a
      href="https://github.com/milvus-io/milvus/issues/4749">#4749</a>, <a
      href="https://github.com/milvus-io/milvus/issues/4757">#4757</a>, <a
      href="https://github.com/milvus-io/milvus/issues/4765">#4765</a>, <a
      href="https://github.com/milvus-io/milvus/issues/4766">#4766</a></li>
</ul>
<blockquote>
  <ul>
    <li>For more information about the features of Milvus 1.0, go to <a
        href="https://zilliz.com/blog/Whats-Inside-Milvus-1.0">What’s Inside Milvus 1.0?</a>.</li>
    <li>For more information about its roadmap, see <a
        href="https://zilliz.com/blog/milvus-1-0-the-worlds-most-popular-open-source-vector-database-just-got-better">Milvus
        1.0: The World’s Most Popular Open-Source Vector Database Just Got Better</a>.</li>
  </ul>
</blockquote>
<h1>Milvus Community Charters</h1>
<h2>Milvus Community Charters</h2>
<h4>About the Milvus community</h4>
<p>Milvus is an open-source vector database that is highly flexible, reliable, and blazing fast. In June 2021, <a
    href="https://lfaidata.foundation/projects/milvus/">Milvus</a> graduated from the LF AI &amp; Data foundation’s
  incubator program after spending 15 months in the incubation phase.</p>
<p>We, as the Milvus community, want to build a fundamental data serving component so that AI applications could go
  production much easier. More and more people start to build up their production AI applications upon Milvus. You can
  find more user stories of Milvus in our <a href="https://medium.com/unstructured-data-service">project blog</a>.</p>
<p>If you are a Milvus user or you have the same vision as us, we would warmly welcome you to join our community.
  Together, we contribute to the project design and participate in the decision making process. Let’s build up a
  community-driven open source AI project.</p>
<h4>Join the community</h4>
<p>All Contributors could find their positions in the Milvus community. If you are interested in <strong>code
    development</strong>, please read thru the chapters of Special Interest Groups and Working Groups. If you want to
  make <strong>non-code contributions</strong>, you can find the opportunities in the chapters of Working Groups and
  Technology Steering Committee.</p>
<p>You could connect with the Milvus community on various channels. Here is the guideline of the community channels.</p>
<ul>
  <li>
    <p>Official website: <a href="https://milvus.io">https://milvus.io</a></p>
  </li>
  <li>
    <p>Community calendar for events and meetings</p>
    <ul>
      <li><a
          href="https://lists.lfaidata.foundation/g/milvus-announce/ics/7812594/1982604167/feed.ics">https://lists.lfaidata.foundation/g/milvus-announce/ics/7812594/1982604167/feed.ics</a>
      </li>
    </ul>
  </li>
  <li>
    <p>Community announcement</p>
    <ul>
      <li>
        <p>Mail list: <a
            href="https://lists.lfaidata.foundation/g/milvus-announce">https://lists.lfaidata.foundation/g/milvus-announce</a>
        </p>
      </li>
      <li>
        <p>Blog:</p>
      </li>
    </ul>
  </li>
  <li>
    <p>User discussions, Q&amp;A</p>
    <ul>
      <li>
        <p><a href="https://join.slack.com/t/milvusio/shared_invite/zt-e0u4qu3k-bI2GDNys3ZqX1YCJ9OM~GQ">Slack
            community</a></p>
      </li>
      <li>
        <p><a href="https://github.com/milvus-io/milvus/discussions">GitHub discussions</a></p>
      </li>
      <li>
        <p>Mail list: <a
            href="https://lists.lfaidata.foundation/g/milvus-technical-discuss">https://lists.lfaidata.foundation/g/milvus-technical-discuss</a>
        </p>
      </li>
    </ul>
  </li>
  <li>
    <p>Bug report &amp; feature request</p>
    <ul>
      <li><a href="https://github.com/milvus-io/milvus/issues">GitHub issues</a></li>
    </ul>
  </li>
  <li>
    <p>Group discussions (for special interest groups and working groups)</p>
    <ul>
      <li>
        <p><a href="https://join.slack.com/t/milvusio/shared_invite/zt-e0u4qu3k-bI2GDNys3ZqX1YCJ9OM~GQ">Slack
            community</a> (1 to 1 conversation, internal group discussion)</p>
      </li>
      <li>
        <p><a href="https://github.com/milvus-io/milvus/discussions">GitHub discussions</a> (internal group discussion
          and public community discussion)</p>
      </li>
      <li>
        <p>Mail list: <a
            href="https://lists.lfaidata.foundation/g/milvus-technical-discuss">https://lists.lfaidata.foundation/g/milvus-technical-discuss</a>
          (public community discussion)</p>
      </li>
    </ul>
  </li>
  <li>
    <p>TSC communication</p>
    <ul>
      <li>Mail list: <a
          href="https://lists.lfaidata.foundation/g/milvus-tsc">https://lists.lfaidata.foundation/g/milvus-tsc</a></li>
    </ul>
  </li>
</ul>
<h5>Code of Conduct</h5>
<p>The Milvus community follows the Milvus <a
    href="https://github.com/milvus-io/milvus/blob/master/CODE_OF_CONDUCT.md">Code of Conduct</a>. Meanwhile, as a Linux
  Foundation project, all Milvus community members should agree to abide by the LF Code of Conduct available at <a
    href="https://lfprojects.org/policies/code-of-conduct/">https://lfprojects.org/policies/code-of-conduct/</a>.</p>
<h4>Community organization</h4>
<p>There are 3 types of groups in the Milvus community.</p>
<ul>
  <li>
    <p>Special interest groups (SIGs)</p>
  </li>
  <li>
    <p>Working groups (WGs)</p>
  </li>
  <li>
    <p>Technology Steering Committee (TSC)</p>
  </li>
</ul>
<p>The below diagram shows how they work together.</p>
<p><img src="../../../assets/community_organization.png" alt="Community Organization"></p>
<h4>Special Interest Groups (SIGs)</h4>
<p>The SIGs are usually aligned to the Milvus system components, technology field, etc. Developers could join the SIGs
  based on their interests. Below is the list of existing SIGs:</p>
<table>
  <thead>
    <tr>
      <th style="text-align:left"><strong>SIGs</strong></th>
      <th style="text-align:center"><strong>Group contact</strong></th>
      <th style="text-align:right"><strong>Group label (GitHub, Slack, etc)</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">The ANNS algorithm SIG</td>
      <td style="text-align:center">Yi Xiaomeng, Li Shengjun</td>
      <td style="text-align:right">sig-anns</td>
    </tr>
    <tr>
      <td style="text-align:left"><a href="sig_engine.md">The Engine SIG</a></td>
      <td style="text-align:center">Yefu Chen, Zhenshan Cao</td>
      <td style="text-align:right">sig-engine</td>
    </tr>
    <tr>
      <td style="text-align:left"><a href="sig_engine.md">The Testing SIG</a></td>
      <td style="text-align:center">YuDong Cai, Zhenxiang Li</td>
      <td style="text-align:right">sig-testing</td>
    </tr>
    <tr>
      <td style="text-align:left"><a href="sig_tool.md">The Toolchain SIG</a></td>
      <td style="text-align:center">Shiyu Chen, Yunmei Li</td>
      <td style="text-align:right">sig-tool</td>
    </tr>
  </tbody>
</table>
<br />
<p>If you want to initiate a new SIG, you need to complete and submit the <a
    href="https://github.com/milvus-io/community/sig/proposal_template.adoc">SIG proposal</a>. The proposal will be
  reviewed and voted on by Milvus Technology Steering Committee (TSC).</p>
<h5>Code contribution guideline</h5>
<p>Please refer: <a href="https://github.com/milvus-io/milvus/blob/master/CONTRIBUTING.md">Contributing to Milvus</a>
</p>
<h5>Developer path in SIGs</h5>
<h6>Participant</h6>
<p>Once you connect to a SIG (subscribe to the community calendar, read thru the group discussion, attend group
  meetings, etc), you are already a participant.</p>
<h6>Contributor</h6>
<p>If your code contribution (thru pull request) is successfully merged into the Milvus codebase, you are a contributor.
</p>
<h6>Reviewer</h6>
<p>After you have provided continued and quality contribution to the Milvus project for at least 6 months and have
  contributed at least one major component. You are eligible to become the reviewer of that component. The SIG leader
  will review and nominate reviewers periodically. You can nominate yourself as well if you want to show more commitment
  to the Milvus project.</p>
<p>Reviewers have the following responsibilities:</p>
<ul>
  <li>
    <p>Participate in feature design discussion and implementation.</p>
  </li>
  <li>
    <p>Ensure the quality of owned code modules.</p>
  </li>
  <li>
    <p>Ensure the technical accuracy of documentation.</p>
  </li>
  <li>
    <p>Quickly respond to issues and PRs and conduct code reviews.</p>
  </li>
</ul>
<h6>Committer</h6>
<p>To become a committer, a reviewer must have contributed broadly throughout the Milvus project. A reviewer must also
  be sponsored by a committer and the sponsorship must be approved by the TSC.</p>
<p>The committer role enables the contributor to commit code directly to the repository, but also comes with the
  responsibilities of being a leader in the community:</p>
<ul>
  <li>
    <p>Lead feature design discussions and implementation.</p>
  </li>
  <li>
    <p>Ensure the overall project quality and approve PRs.</p>
  </li>
  <li>
    <p>Participate in product release, feature planning, and roadmap design.</p>
  </li>
  <li>
    <p>Have a constructive and friendly attitude in all community interactions.</p>
  </li>
  <li>
    <p>Mentor reviewers and contributors.</p>
  </li>
  <li>
    <p>In general, continue to be willing to spend at least 25% of one’s time working on the project (~1.25 business
      days per week).</p>
  </li>
</ul>
<h5>Conflict resolution and voting</h5>
<p>In general, we prefer that technical issues and committer membership are amicably worked out between the persons
  involved. If a dispute cannot be decided independently, the committers can be called in to decide an issue. If the
  committers themselves cannot decide an issue, the issue will be resolved by voting. The voting process is a simple
  majority in which each committer receives one vote.</p>
<h4>Working Groups (WGs)</h4>
<p>Some types of work (for example, release, documentation, etc) requires collaboration across different SIGs. We set up
  working groups to ensure the smooth proceeding of these types of work. Base on the nature of the work, there are 2
  types of working groups, permanent working groups, and on-demand working groups. Below is the list of existing WGs.
</p>
<h5>Permanent WGs</h5>
<table>
  <thead>
    <tr>
      <th style="text-align:left">left</th>
      <th style="text-align:center">center</th>
      <th style="text-align:right">right</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left"><a href="wg_release.md">The Release WG</a></td>
      <td style="text-align:center">Xiangyu Wang</td>
      <td style="text-align:right">wg-release</td>
    </tr>
    <tr>
      <td style="text-align:left">The Documentation WG</td>
      <td style="text-align:center">Keith Cai</td>
      <td style="text-align:right">wg-doc</td>
    </tr>
    <tr>
      <td style="text-align:left"><a href="wg_devrel.md">The DevRel WG</a></td>
      <td style="text-align:center">Kate Shao</td>
      <td style="text-align:right">wg-devrel</td>
    </tr>
  </tbody>
</table>
<h5>On-demand WGs</h5>
<table>
  <thead>
    <tr>
      <th style="text-align:left">left</th>
      <th style="text-align:center">center</th>
      <th style="text-align:right">right</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left"><a href="wg_grad.md">The Graduation WG</a></td>
      <td style="text-align:center">Jun Gu</td>
      <td style="text-align:right">wg-grad</td>
    </tr>
  </tbody>
</table>
<br />
<h4>Technology Steering Committee (TSC)</h4>
<p>The Milvus project is legally owned by the Linux Foundation. Milvus TSC is the facilitator of the Milvus project. The
  TSC members ensure the success of the Milvus project.</p>
<h5>Responsibilities:</h5>
<ol>
  <li>
    <p>Create and dismiss SIGs and working groups</p>
  </li>
  <li>
    <p>Nominate and vote on new project committers</p>
  </li>
  <li>
    <p>Provide support, guidance, resources, etc. to SIGs and working groups</p>
  </li>
  <li>
    <p>Other Milvus related operation work</p>
  </li>
</ol>
<h5>TSC Members:</h5>
<ol>
  <li>
    <p>Committers</p>
  </li>
  <li>
    <p>Project facilitators (sponsors, project operation leader, invited advisors)</p>
  </li>
</ol>
<h4>Credits</h4>
<p>The contents of this document are based on the <a
    href="http://oss-watch.ac.uk/resources/meritocraticgovernancemodel">Meritocratic Governance Model</a> by Ross
  Gardler and Gabriel Hanganu with some additions from the <a
    href="https://github.com/pingcap/community/blob/master/GOVERNANCE.md">TiDB Community Governance</a>.</p>
<h2>Special Interest Groups (SIGs)</h2>
<h3>The ANNS SIG</h3>
<h4>The ANNS Special Interest Group</h4>
<h4>About the ANNS Special Interest Group</h4>
<h4>The group subject</h4>
<p>The ANNS special interest group focuses on:</p>
<ul>
  <li>
    <p>Research and support more index and metric types in Milvus</p>
  </li>
  <li>
    <p>Improve the building and searching efficiency</p>
  </li>
  <li>
    <p>Develop autonomous tools for index type and parameter choosing</p>
  </li>
</ul>
<h4>The group members</h4>
<ul>
  <li>
    <p>Group leaders</p>
    <ul>
      <li>
        <p>Xiaomeng Yi (GitHub: yxm1536)</p>
      </li>
      <li>
        <p>Shengjun Li (GitHub: shengjun1985)</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Group members</p>
    <ul>
      <li>
        <p>QianYa Chen (GitHub: cqy123456)</p>
      </li>
      <li>
        <p>ChengMing Li (GitHub: op-hunter)</p>
      </li>
    </ul>
  </li>
</ul>
<h4>The group communication channels</h4>
<ul>
  <li>
    <p><a href="https://join.slack.com/t/milvusio/shared_invite/zt-e0u4qu3k-bI2GDNys3ZqX1YCJ9OM~GQ">Slack community</a>
      (1 to 1 conversation, internal group discussion)</p>
  </li>
  <li>
    <p><a href="https://github.com/milvus-io/milvus/discussions">GitHub discussions</a> (internal group discussion and
      public community discussion)</p>
  </li>
  <li>
    <p>Mail list: <a
        href="https://lists.lfaidata.foundation/g/milvus-technical-discuss">https://lists.lfaidata.foundation/g/milvus-technical-discuss</a>
      (public community discussion)</p>
  </li>
</ul>
<h3>The Engine SIG</h3>
<h4>The Engine Special Interest Group</h4>
<h4>About the Engine Special Interest Group</h4>
<h4>The group subject</h4>
<p>The Engine special interest group focuses on:</p>
<ul>
  <li>
    <p>Adapt Milvus engine into the cloud-native environment</p>
  </li>
  <li>
    <p>Switch to golang in the future development of the Milvus engine (while the ANNS algorithm component will still be
      developed by C++)</p>
  </li>
</ul>
<h4>The group members</h4>
<ul>
  <li>
    <p>Group leaders</p>
    <ul>
      <li>
        <p>Yefu Chen (GitHub: neza2017)</p>
      </li>
      <li>
        <p>Zhenshan Cao (GitHub: czs007)</p>
      </li>
    </ul>
  </li>
</ul>
<h4>The group communication channels</h4>
<ul>
  <li>
    <p><a href="https://join.slack.com/t/milvusio/shared_invite/zt-e0u4qu3k-bI2GDNys3ZqX1YCJ9OM~GQ">Slack community</a>
      (1 to 1 conversation, internal group discussion)</p>
  </li>
  <li>
    <p><a href="https://github.com/milvus-io/milvus/discussions">GitHub discussions</a> (internal group discussion and
      public community discussion)</p>
  </li>
  <li>
    <p>Mail list: <a
        href="https://lists.lfaidata.foundation/g/milvus-technical-discuss">https://lists.lfaidata.foundation/g/milvus-technical-discuss</a>
      (public community discussion)</p>
  </li>
</ul>
<h3>The Testing SIG</h3>
<h4>The Testing Special Interest Group</h4>
<h4>About the Testing Special Interest Group</h4>
<h4>The group subject</h4>
<p>The Testing special interest group focuses on:</p>
<ul>
  <li>
    <p>Build the efficient testing service and reliable、continuous integration facilities, to make it easier and more
      efficient for the community to run test cases</p>
  </li>
  <li>
    <p>Working with other sig groups, find new issues in the project, and close fixed issues relying on the stable
      testing infrastructure and services</p>
  </li>
</ul>
<h4>The subgroups in Testing SIG</h4>
<ul>
  <li><strong>test-infra</strong></li>
</ul>
<p>Build CI/CD infrastructure and pipelines for the project, publish friendly deployment for the project to make it
  easier to create, install and upgrade the environment</p>
<ul>
  <li><strong>test-framework</strong></li>
</ul>
<p>Build layered testing scripts, tools, and services, schedule and execute the test tasks (including functional test,
  benchmark test, and stability test)</p>
<ul>
  <li><strong>test-commons</strong></li>
</ul>
<p>Focus on the ease of use around the server and SDKs, including the execution of functional testing, to ensure the
  server and SDKs are published and delivered under the original demands and expected quality</p>
<h4>The group members</h4>
<ul>
  <li>
    <p>Group leaders</p>
    <ul>
      <li>
        <p>Yudong Cai (GitHub: cydrain)</p>
      </li>
      <li>
        <p>Zhenxiang Li (GitHub: del-zhenwu)</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Group members</p>
    <ul>
      <li>
        <p>Zhifeng Zhang (GitHub: jeffoverflow)</p>
      </li>
      <li>
        <p>Yufen Zong (GitHub: ThreadDao)</p>
      </li>
      <li>
        <p>Ting Wang (GitHub: wangting0128)</p>
      </li>
    </ul>
  </li>
</ul>
<h4>The group communication channels</h4>
<ul>
  <li>
    <p><a href="https://join.slack.com/t/milvusio/shared_invite/zt-e0u4qu3k-bI2GDNys3ZqX1YCJ9OM~GQ">Slack community</a>
      (1 to 1 conversation, internal group discussion)</p>
  </li>
  <li>
    <p><a href="https://github.com/milvus-io/milvus/discussions">GitHub discussions</a> (internal group discussion and
      public community discussion)</p>
  </li>
  <li>
    <p>Mail list: <a
        href="https://lists.lfaidata.foundation/g/milvus-technical-discuss">https://lists.lfaidata.foundation/g/milvus-technical-discuss</a>
      (public community discussion)</p>
  </li>
</ul>
<h3>The Toolchain SIG</h3>
<h4>The Toolchain Special Interest Group</h4>
<h4>About the Toolchain Special Interest Group</h4>
<h4>The group subject</h4>
<p>The Toolchain special interest group focuses on:</p>
<ul>
  <li>
    <p>Good data management. Makes it easier to manage Milvus data.</p>
  </li>
  <li>
    <p>Other tools that reduce the effort for Milvus administration and maintenance.</p>
  </li>
  <li>
    <p>If you have any good ideas for Milvus Toolchain, let’s <a
        href="https://github.com/milvus-io/milvus/discussions/4782">discuss here</a>.</p>
  </li>
</ul>
<h4>The group members</h4>
<ul>
  <li>
    <p>Group leaders</p>
    <ul>
      <li>
        <p>Chen Shiyu (GitHub: shiyu22)</p>
      </li>
      <li>
        <p>Li Yunmei (GitHub: Bennu-Li)</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Group members</p>
    <ul>
      <li>
        <p>Li Qing (GitHub: miia12)</p>
      </li>
      <li>
        <p>Jia Jingjing (GitHub: jingkl)</p>
      </li>
    </ul>
  </li>
</ul>
<h4>The group communication channels</h4>
<ul>
  <li>
    <p><a href="https://join.slack.com/t/milvusio/shared_invite/zt-e0u4qu3k-bI2GDNys3ZqX1YCJ9OM~GQ">Slack community</a>
      (1 to 1 conversation, internal group discussion)</p>
  </li>
  <li>
    <p><a href="https://github.com/milvus-io/milvus/discussions">GitHub discussions</a> (internal group discussion and
      public community discussion)</p>
  </li>
  <li>
    <p>Mail list: <a
        href="https://lists.lfaidata.foundation/g/milvus-technical-discuss">https://lists.lfaidata.foundation/g/milvus-technical-discuss</a>
      (public community discussion)</p>
  </li>
</ul>
<h2>Working Groups (WGs)</h2>
<h3>The Release WG</h3>
<h4>The Release Working Group</h4>
<h4>About the Release Working Group</h4>
<h4>The group subject</h4>
<p>The release working group (WG-release) ensures the quality of the Milvus release:</p>
<ul>
  <li>Set up and maintain the test automation infrastructure for CI/CD, integration testing, benchmark testing, etc</li>
  <li>Build the regular release in a timely manner</li>
  <li>Coordinate with different development SIGs for a new milestone release</li>
</ul>
<h4>The group members</h4>
<ul>
  <li>
    <p>Group leaders</p>
    <ul>
      <li>Xiangyu Wang (GitHub: scsven)</li>
    </ul>
  </li>
</ul>
<h4>The group communication channels</h4>
<ul>
  <li>
    <p><a href="https://join.slack.com/t/milvusio/shared_invite/zt-e0u4qu3k-bI2GDNys3ZqX1YCJ9OM~GQ">Slack community</a>
      (1 to 1 conversation, internal group discussion)</p>
  </li>
  <li>
    <p><a href="https://github.com/milvus-io/milvus/discussions">GitHub discussions</a> (internal group discussion and
      public community discussion)</p>
  </li>
  <li>
    <p>Mail list: <a
        href="https://lists.lfaidata.foundation/g/milvus-technical-discuss">https://lists.lfaidata.foundation/g/milvus-technical-discuss</a>
      (public community discussion)</p>
  </li>
</ul>
<p>Special communication rules:</p>
<ul>
  <li>The release note of any release should be posted to ，<a
      href="mailto:milvus-announce@lists.lfaidata.foundation">milvus-announce@lists.lfaidata.foundation</a></li>
</ul>
<h4>Reference</h4>
<ul>
  <li><a href="milvus_release_guideline.md">The Milvus Release Guideline</a></li>
</ul>
<h3>The DevRel WG</h3>
<h4>The DevRel Working Group</h4>
<h4>About the DevRel Working Group</h4>
<h4>The group subject</h4>
<p>The DevRel working group focuses on:</p>
<ul>
  <li>
    <p><strong>Community Outreach</strong></p>
    <p>-Speaking at conferences/giving talks.</p>
    <p>-Being active on social media and technical forums to promote Milvus.</p>
    <p>-Creating content such as blogs, video tutorials, newsletters, etc.</p>
    <p>-Hosting/attending events (meetups, webinars, hackathons, workshops, DevRel working group’s regular meetings,
      etc.)</p>
  </li>
  <li>
    <p><strong>Developer Experience &amp; Success</strong></p>
    <p>-Facilitating smooth developer onboarding by creating documentation and tools.</p>
    <p>-Building demos.</p>
    <p>-Answering questions or providing guidance to developers/users on GitHub, StackOverflow, Slack, etc.</p>
    <p>-Understanding user pain points and giving feedback to the product team for creating better products.</p>
  </li>
  <li>
    <p><strong>Community Building</strong></p>
    <p>-Continuously developing and refining Milvus Ambassador Program to keep the DevRel working group growing.</p>
    <p>-Helping community members to find and join other appropriate Milvus SIGs.</p>
  </li>
</ul>
<h4>The group members</h4>
<ul>
  <li>Group leaders
    <ul>
      <li>Kate Shao (GitHub: kateshaowanjou)</li>
    </ul>
  </li>
</ul>
<h4>The group communication channels</h4>
<ul>
  <li>
    <p><a href="https://join.slack.com/t/milvusio/shared_invite/zt-e0u4qu3k-bI2GDNys3ZqX1YCJ9OM~GQ">Slack community</a>
      (1 to 1 conversation, internal group discussion)</p>
  </li>
  <li>
    <p><a href="https://github.com/milvus-io/milvus/discussions">GitHub discussions</a> (internal group discussion and
      public community discussion)</p>
  </li>
  <li>
    <p>Mail list: <a
        href="https://lists.lfaidata.foundation/g/milvus-technical-discuss">https://lists.lfaidata.foundation/g/milvus-technical-discuss</a>
      (public community discussion)</p>
  </li>
</ul>
<h3>The Graduation WG</h3>
<h4>The Graduation Working Group</h4>
<h4>About the Graduation Working Group</h4>
<h4>The group subject</h4>
<p>This is an on-demand working group. The Graduation working group is set up to ensure the successful graduation of
  Milvus from the incubating stage in the LF AI &amp; Data foundation. The graduation working group will be dismissed
  afterward.</p>
<h4>The objectives:</h4>
<ul>
  <li>Fulfill all the graduation criteria requested by the LF AI &amp; Data foundation</li>
  <li>Prepare and present the Milvus graduation deck to the governing board of the LF AI &amp; Data foundation</li>
  <li>Graduate before Jun. 30th, 2021</li>
</ul>
<h4>The group members</h4>
<ul>
  <li>Group leaders
    <ul>
      <li>Jun Gu (GitHub: gujun720)</li>
    </ul>
  </li>
</ul>
<h4>The group communication channels</h4>
<ul>
  <li>
    <p><a href="https://join.slack.com/t/milvusio/shared_invite/zt-e0u4qu3k-bI2GDNys3ZqX1YCJ9OM~GQ">Slack community</a>
      (1 to 1 conversation, internal group discussion)</p>
  </li>
  <li>
    <p><a href="https://github.com/milvus-io/milvus/discussions">GitHub discussions</a> (internal group discussion and
      public community discussion)</p>
  </li>
  <li>
    <p>Mail list: <a
        href="https://lists.lfaidata.foundation/g/milvus-technical-discuss">https://lists.lfaidata.foundation/g/milvus-technical-discuss</a>
      (public community discussion)</p>
  </li>
</ul>
<h2>Project Guidelines</h2>
<h3>The Milvus Release Guideline</h3>
<h4>The Milvus release guideline</h4>
<h4>Regular release</h4>
<p>There are 2 types of regular releases, monthly and weekly.</p>
<h4>Monthly feature release</h4>
<p>The target date of the monthly feature release is on the 1st Fri. of a month. We will merge the new features into the
  monthly feature release.</p>
<h4>Weekly bugfix release</h4>
<p>The target date of the weekly bugfix release is on every Fri. other than the 1st Fri. of a month. We will merge the
  latest bugfixes into the weekly bugfix release.</p>
<h4>Milestone release</h4>
<p>When Milvus evolves to a certain stage (milestone), Milvus committers could propose to build a milestone release. The
  proposal will be voted in Milvus TSC (simple majority).</p>
<p>The initiator should consider the below aspects in the milestone release proposal.</p>
<ul>
  <li>What is the purpose of the milestone release?</li>
  <li>Is it a long-term support release? What is the end of support (EOS) date?</li>
  <li>What is the future development strategy for this milestone release/branch?</li>
</ul>
<h4>Milvus version number explanation</h4>
<p>The traditional software version number follows the format as “version.release.modification”. While open source
  software (OSS) usually builds more frequent, periodical releases, so the style of OSS version number would be quite
  different.</p>
<p>When Milvus first launched on GitHub, we set the Milvus version number as 0.y.z. The leading “0” means this is a
  young, early project. The middle “y” increments every time we build a release. And the ending “z” is the fix-pack
  number of a release.</p>
<p>After we elevate Milvus 0.10.x to Milvus 1.0 beta. The format of the Milvus version number would be x.y.z.</p>
<ul>
  <li>x: current milestone + 1.</li>
  <li>y: starting from 0, incrementing after every monthly regular release.</li>
  <li>z: starting from 0, incrementing after every weekly regular release, recycled after next monthly regular release.
  </li>
</ul>
<p>For example, after we release Milvus 1.0.0 milestone, the developing version would start from 2.0.0.</p>